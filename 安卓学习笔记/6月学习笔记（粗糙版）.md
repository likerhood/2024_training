# 安卓开发
[TOC]

## 0. 前言
目前还不错的博客：
[环境搭建和日志使用](https://blog.csdn.net/yang2330648064/article/details/129008294)
[开源安卓项目教程](https://blog.csdn.net/weixin_43853746/article/details/117367078)
[适合简洁快速的查找相关组件使用](https://www.twle.cn/l/yufei/android/android-basic-gridlayout.html)
[ConstraintLayout布局的性能比较](https://mp.weixin.qq.com/s/gGR2itbY7hh9fo61SxaMQQ)
[布局案例中有简洁代码](https://blog.csdn.net/JMW1407/article/details/114622919)
[Android可视化界面布局开发技巧](https://blog.csdn.net/qq_34519487/article/details/104134467?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-104134467-blog-9157315.235^v43^pc_blog_bottom_relevance_base3&spm=1001.2101.3001.4242.1&utm_relevant_index=1)


## 1. andriod studio安装
安装流程：
1. 首先电脑安装JDK、开启允许虚拟化；
2. 官网下载andriod studio；
3. 点击安装选项时用costum模式选择下载相应选项；
4. 新建空项目，点击右侧的Device Manager启动安卓手机模拟器；
5. 编译运行项目，右侧会显示安卓软件。

划重点：
1. **安装参考教程 [移动应用开发环境搭建Android Studio](https://blog.csdn.net/yang2330648064/article/details/129008294)**

2. 关于报错
    - 编译运行按钮变灰 [Android studio解决关于解压项目 no moudle app打叉问题](https://blog.csdn.net/weixin_53640905/article/details/129331272?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-129331272-blog-109451545.235%5Ev43%5Epc_blog_bottom_relevance_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-129331272-blog-109451545.235%5Ev43%5Epc_blog_bottom_relevance_base3&utm_relevant_index=2)
    - no module问题解决 [Android Studio 解决 no module](https://heliquan.blog.csdn.net/article/details/100790269?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-100790269-blog-129331272.235%5Ev43%5Epc_blog_bottom_relevance_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-100790269-blog-129331272.235%5Ev43%5Epc_blog_bottom_relevance_base3&utm_relevant_index=2)

成功界面：
![alt text](img/image.png)



## 2. 项目目录结构
APP工程分为两个层次，一个是项目，一个是模块。
每个项目至少一个模块，一个模块编译一个APP，就是指运行一个模块，而不是一个项目。类似前端的一个页面。
![alt text](img/30dba7091339ead0e3e1719b6acd971f.jpg)

**gradle**
一种自动编译运行打包项目的工具，类似c++里面的Cmake工具。

在Android Studio中，有不同的视图（views），以帮助开发者更好地管理和组织项目。这些视图提供了不同的角度来查看和处理项目中的文件和资源，方便开发者根据需要快速找到和编辑相关内容。下面主要介绍Project模式和android模式。

### 2.1 Android模式
“Android模式”通过按类别组织文件，使得查找和管理文件更加直观和方便，特别是对Android开发者而言。

目录图片：
![alt text](img/image-1.png)

目录结构：
```
MyApplication
    ├── manifests
    │   └── AndroidManifest.xml  (APP运行配置文件)
    ├── java （3个com.example.myapp包，分别是源代码和测试代码）
    │   ├── com.example.myapplication (你的应用程序包)
    │   │   ├── MainActivity.java
    │   │   └── ... (更多的Java/Kotlin文件)
    │   └── ... (测试文件等)
    └── res （当前模块的资源文件）
        ├── drawable
        │   └── ... (图像资源)
        ├── layout
        │   └── activity_main.xml (布局文件)
        ├── mipmap
        │   └── ic_launcher.png (启动图标)
        ├── values
        │   ├── strings.xml (字符串资源)
        │   ├── colors.xml (颜色资源)
        │   └── styles.xml (样式资源)
        └── ... (其他资源文件)
    └── Gradle Scripts （工程的编译配置文件）
        ├── build.gradle.kts （分别包括项目级和模块级的编译规则）
        ├── proguard-rules.pro (java代码混淆规则)
        ├── gradle.properties (配置编译工程的命令行参数，一般不动)
        ├── settings.gradle (配置需要编译哪些模块，初始为 include':app' , 表示只编译app模块)
        └── local.properties （项目本地的配置文件，描述开发者的电脑环境）
```

### 2.2 Project 模式
Project 模式有利于显示项目的完整文件系统结构，包括构建脚本、配置文件和IDE设置等。适用于需要深入了解和管理项目各个细节的开发者。

目录图片：
![alt text](img/image-2.png)


目录结构：
```
MyApplication
    ├── .idea (IDE相关设置)
    ├── .gradle （自动编译工具gradle产生的文件）
    ├── app （工程中的模块——Module）
    │   ├── build （工程编译目录）
    │   ├── src （源文件）
    │   │   ├── main
    │   │   │   ├── AndroidManifest.xml
    │   │   │   ├── java
    │   │   │   │   └── com.example.myapplication
    │   │   │   │       └── MainActivity.java
    │   │   │   ├── res (资源存放在这里)
    │   │   │   │   ├── drawable
    │   │   │   │   ├── layout
    │   │   │   │   └── values
    │   │   │   └── AndroidManifest.xml （APP配置文件，程序中定义的所以四大组件都需要在这个文件里注册）
    │   │   └── test （测试代码）
    │   └── build.gradle （gradle项目自动编译的配置文件）
    ├── gradle    （gradle构建目录，gradle环境支持文件夹）
    ├── build.gradle （gradle项目自动编译的配置文件，这是项目全局的gradle构建脚本）
    ├── gradle.properties (gradle运行环境配置文件)
    └── ...

```

## 3. 清单文件
在Android Studio中的清单文件（`AndroidManifest.xml`）是每个Android应用的核心配置文件。它提供了应用的基本信息和配置，定义了应用的组件、权限、硬件和软件特性等。


下面是一个典型的 `AndroidManifest.xml` 文件的示例及其各部分的作用：

```XML
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myapplication"    //定义应用的包名，必须是唯一的，通常与应用在Google Play上的ID对应。
    android:versionCode="1"        // 应用的内部版本号
    android:versionName="1.0">    //根目录

    <uses-permission android:name="android.permission.INTERNET"/>        // 指定权限的名称，表示应用需要访问互联网。
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>    // 权限允许应用访问网络状态信息。

    <application
        android:allowBackup="true"        // 指定应用是否允许备份数据
        android:icon="@mipmap/ic_launcher"    //应用图标的资源ID
        android:label="@string/app_name"    //应用的标签（名称），用户可见。
        android:roundIcon="@mipmap/ic_launcher_round"    // 应用的圆形图标的资源ID。
        android:supportsRtl="true"    //指定应用是否支持从右到左的布局方向
        android:theme="@style/AppTheme">    // 应用的主题资源ID。
        
        <activity android:name=".MainActivity">        // 定义一个Activity，Activity是应用中的一个单独的用户界面组件。并指明入口界面
            <intent-filter>        // 定义Activity可以响应的Intent。
                <action android:name="android.intent.action.MAIN" />        // 指定Activity的动作。
                <category android:name="android.intent.category.LAUNCHER" />    // 指定Activity的类别
            </intent-filter>
        </activity>
        
    </application>

</manifest>
```

## 4. 界面显示和逻辑处理
类似网页开发的前端，安卓开发用XML文件描述界面，用java实现界面的逻辑跳转和运算。其中关于界面的XML在res文件的layout中，java代码在src源码中。

### 4.1 四大组件
应用组件用于显示界面和数据交互，四大组件包括：
1. Activity（活动）；
2. Service（服务）；
3. Content Provider（内容提供者）；
4. Broadcast Receiver（广播接收者）。

应用到的组件都需要在清单文件声明。

#### 4.1.1 活动（Activity）
1. 是用户操作的可视化界面；它为用户提供了一个完成操作指令的窗口。
2. 当我们创建完毕Activity之后，**需要调用setContentView()方法来完成界面的显示**；以此来为用户提供交互的入口。


#### 4.1.2 服务（Service）
1. 服务是Android中实现**程序后台运行**的解决方案；
2. 服务并不是运行在一个独立的进程当中的，而是依赖于创建服务时所在的应用程序进程。

例如播放音乐，下载文件。

#### 4.1.3 内容提供者（Content Provider）
1. 应用程序之间共享数据；
2. 比如你想要读取系统电话簿中的联系人，就需要通过内容提供者来实现。

#### 4.1.4 广播接收器（Broadcast Receiver）
广播接收器可以允许你的应用接收来自各处的广播消息，比如电话、短信等，当然你的应用同样也可以向外发出广播消息。



### 4.2 activity 生命周期
一个简洁的表格总结：

| 生命周期方法 | 作用 |
|--------------|------|
| `onCreate()` | 初始化Activity。设置布局、初始化数据、绑定视图等。 |
| `onStart()`  | 做一些界面即将显示时的准备工作。Activity 从不可见变为可见。 |
| `onResume()` | Activity 已经可见并且可以与用户交互。通常在此处开始动画、音乐等交互操作。 |
| `onPause()`  | Activity 进入暂停状态。保存未保存的状态或数据，停止动画和其他资源密集操作。 |
| `onStop()`   | Activity 不再可见。释放不再需要的资源，可以在这里做持久化数据存储。 |
| `onRestart()`| 在 Activity 被停止后再次启动之前调用。重新初始化资源。 |
| `onDestroy()`| Activity 即将被销毁。清理所有资源，释放内存，防止内存泄漏。 |

具体流程图：
![alt text](img/image-3.png)


## 5. 简单控件

### 5.1 文本显示
#### 5.1.1 文本内容显示
1. 在XML布局文件中，使用TextView控件来显示文本。
```XML
<TextView
        android:id="@+id/hello"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!" />
```

2. 在java代码中通过TextView的ID引用它，并设置或更改其文本;
```java
package com.example.test;
// 省略大部分import了
import android.os.Bundle;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);     // 确保父类的初始化逻辑被执行。
        setContentView(R.layout.activity_main); // 设置Activity的布局文件。
        TextView tv_hello = findViewById(R.id.hello);   
        tv_hello.setText(R.string.hello);

    }
}
```

**注意：R类是什么？**
在Android开发中，`R` 是一个非常重要的类，它是由Android的构建工具自动生成的，用于管理应用的所有资源。
**`R` 类中包含了应用程序中所有资源的引用**，如布局文件、字符串、图像等。每个资源都分配了一个唯一的整数ID。

1. 定义：
    `R` 类位于 `gen`（或 `build/generated`）目录下，是一个静态类，Android Studio会在编译时根据项目中的资源文件自动生成这个类。

2. 结构

`R` 类包含若干嵌套的静态类，每个静态类对应一种资源类型。例如：

- `R.layout`：包含布局文件的资源ID。
- `R.id`：包含视图元素的资源ID。
- `R.string`：包含字符串资源的ID。
- `R.drawable`：包含图片资源的ID。
- `R.color`：包含颜色资源的ID。
- `R.raw`：包含原始资源文件的ID。

3. 生成过程
    1. **编译时生成**：每次编译项目时，Android Studio会扫描项目中的所有资源文件，并根据这些文件生成 `R` 类。
    2. **资源ID分配**：每个资源文件都会被分配一个唯一的整数ID，存储在 `R` 类的相应静态嵌套类中。
    3. **自动更新**：当你添加、修改或删除资源文件时，`R` 类会自动更新，以反映最新的资源状态。


#### 5.1.2 文本大小设置
文本大小单位相关：
通常组件用dp、文字用sp。
| 单位        | 定义                                                                                  | 用途                                                   | 示例                              |
|-------------|---------------------------------------------------------------------------------------|--------------------------------------------------------|-----------------------------------|
| `sp`        | Scale-independent Pixels，与屏幕密度无关的像素，受用户字体设置影响                    | 设置文本大小                                           | `android:textSize="16sp"`         |
| `dp`        | Density-independent Pixels，与屏幕密度无关的像素                                     | 设置视图大小和位置                                     | `android:layout_width="16dp"`     |
| `dpi`       | Dots Per Inch，每英寸的像素点数，用于描述屏幕的像素密度                              | 用于计算 `dp` 和 `sp` 与物理像素的转换                 | 常见值：160dpi（中密度），320dpi（高密度） |
| `px`        | Pixels，屏幕上的物理像素                                                              | 精确控制像素（一般不推荐用于文本大小）                 | `android:layout_width="16px"`     |
| `resolution`| 屏幕分辨率，指屏幕的像素总数，通常表示为宽度 x 高度，例如 1080 x 1920                | 描述设备屏幕的总像素数                                 | 1080 x 1920, 1440 x 2560           |

方式：
1. TextView中的testSize属性；
2. java中调用setTextSize函数，单位默认sp；

#### 5.1.3 文本颜色
1. TextView中的testColor属性；
2. java中调用setTextColor函数。

### 5.2 视图基础
#### 5.2.1 宽高
1. 布局XML文件中通过以下两个属性设置：
    - android:layout_width；
    - android:layout_height；
2. 属性值包括：
    - 具体数值dp、px；
    - 特定值：
        - wrap_content：视图的大小根据其内容确定；
        - match_parent（：视图的大小扩展以匹配其父视图的大小。

#### 5.2.2 间距
1. 布局XML文件中通过以下两个属性设置：(padding没有layout标记hhh)
    - android:layout_margin，外边距；
    - android:padding，内边距；
2. 属性值一般是数值。

```XML
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="This is a TextView"
        android:padding="10dp"
        android:layout_marginBottom="20dp" />

    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Click Me"
        android:layout_marginTop="20dp"
        android:padding="10dp" />

</LinearLayout>

```

#### 5.2.3 对齐方式
1. layout_gravity
    - 作用：设置视图**相对于其父布局的对齐方式**，即视图在父布局中的位置。
    - 适用范围：FrameLayout、LinearLayout、RelativeLayout 等布局容器。
    - 可选值：top、bottom、left、right、center_vertical、center_horizontal 等。

2. gravity
    - 作用：用于设置**视图内部内容的对齐方式**。
    - 适用范围：TextView、Button、ImageView 等具有内部内容的视图。
    - 可选值：top、bottom、left、right、center_vertical、center_horizontal 等。


### 5.3 布局
参考资料：[链接](https://blog.csdn.net/JMW1407/article/details/114622919)

#### 5.3.1 线性布局LinearLayout
LinearLayout沿着水平或垂直方向排列其子视图。

主要属性：
1. android:orientation ：布局方向；
    - 水平布局horizontal；
    - 垂直布局vertical
2. android:layout_weight：权重；
    - 除了被显示占据的空间以外的的空间，然后根据权重的大小来分配空间。
    - 使用权重**通常会把分配该权重方向的宽度设置为0dp**，如果未设置0dp，则该控件会占据指定的宽度，然后再加上根据权重来分配的空间。

#### 5.3.2 相对布局 RelativeLayout
用于设置某一个控件相对于其他控件的位置，这些位置可以包括上下左右等，因此相较于其他的布局方式而言具有很大的灵活性。

![alt text](img/image-4.png)

1. 父容器定位属性示意图
![alt text](img/image-5.png)
2. 根据兄弟组件定位
![alt text](img/image-6.png)

图中的组件1,2就是兄弟组件了,而组件3与组件1或组件2并不是兄弟组件,所以组件3不能通过 组件1或2来进行定位,比如layout_toleftof = "组件1"这样是会报错的！

#### 5.3.3 约束布局 ConstraintLayout
ConstraintLayout用于实现复杂的界面布局。**它引入了约束（Constraint）的概念**，允许开发者通过在视图之间创建约束关系来定义视图的位置和大小，从而实现灵活且可适应不同屏幕尺寸的布局，**减少布局嵌套**。还可以可视化编辑。

ConstraintLayout布局性能分析：[链接](https://mp.weixin.qq.com/s/gGR2itbY7hh9fo61SxaMQQ)

相关属性讲解：
    [链接1](https://blog.csdn.net/JMW1407/article/details/114622919)
    [链接2](https://www.twle.cn/l/yufei/android/android-basic-constraintlayout.html)


#### 5.3.4 网格布局 GridLayout
创建网格状布局的容器，它将子视图排列成行和列的网格结构。

1. GridLayout组件设置属性有：
    - android:rowCount：子视图行数；
    - android:columnCount：子视图列数；
2. 下面子视图的位置：
    - android:layout_row	设置组件位于第几行，都是从0开始。
    - android:layout_column	设置组件位于第几列
3. 设置子视图跨行和列：
    - android:layout_rowSpan	设置组件跨几行
    - android:layout_columnSpan	设置组件跨几列

参考资料：[链接](https://www.twle.cn/l/yufei/android/android-basic-gridlayout.html)


### 5.4 按钮
按钮控件中常用的事件是点击监听和长按监听。

监听器，意思是专门监听控件的动作行为，发生对应对坐，会出发监听器去执行相关逻辑。

1. 点击监听器:
    - `setOnClickListener` 函数设置，按钮被按住的时间少于500ms触发该事件。
    - 参考教程链接：[setOnclickListener讲解](https://www.cnblogs.com/hyacinthLJP/p/14313712.html)
    - 其他点击类型的监听器用法类似。
2. 按钮的禁用和恢复：
    - 禁用按钮的属性是：android:enabled="true/false"；
    - 参考教程链接：[按钮的禁用和恢复](https://blog.csdn.net/m0_52238102/article/details/125443379)

核心代码举例：
```java
package com.example.test;

import android.graphics.Color;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;
import com.example.test.util.DateUtil;

public class buttonTestActivity extends AppCompatActivity {

    private TextView tv_result;
    public TextView tv_test;
    public Button btnTest;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_button_test);
        tv_result = findViewById(R.id.tv_result);
//      展示点击时间按钮

        Button btn_click_showTime = findViewById(R.id.bnt_show);
//        接口，setOnClickListener是view的一个内部类
        btn_click_showTime.setOnClickListener(new MyOnClickListener(tv_result));

//        打印信息的按钮
        Button btnClickPrintName = findViewById(R.id.bnt_print_name);
        btnClickPrintName.setOnClickListener(new publicButtonClick());
        Button btnClickPrintSchool = findViewById(R.id.bnt_print_school);
        btnClickPrintSchool.setOnClickListener(new publicButtonClick());

//        禁用和启用按钮
        Button btnEnable = findViewById(R.id.btn_enable);
        btnEnable.setOnClickListener(new publicButtonClick());
        Button btnDisable = findViewById(R.id.btn_disable);
        btnDisable.setOnClickListener(new publicButtonClick());

        tv_test = findViewById(R.id.tv_test);
        btnTest = findViewById(R.id.btn_test);
        btnTest.setOnClickListener(new publicButtonClick());


    }

//    内部类
    static class MyOnClickListener implements View.OnClickListener{
        private final TextView tv_result;
        public MyOnClickListener(TextView tv_result){
            this.tv_result = tv_result;
        }
        @Override
        public void onClick(View v) {
            String desc = String.format("%s 您点击了按钮 ：%s", DateUtil.getNowTime(), ((Button) v).getText());
            tv_result.setText(desc);
        }
    }

//    设置按钮点击的公共类实现
    protected class publicButtonClick implements  View.OnClickListener{

        @Override
        public void onClick(View v){
            if(v.getId() == R.id.bnt_print_name){
                Toast t = Toast.makeText(buttonTestActivity.this,"李珂你好",Toast.LENGTH_SHORT);
                t.show();
            }else if(v.getId() == R.id.bnt_print_school) {
                Toast t = Toast.makeText(buttonTestActivity.this, "武汉科技大学", Toast.LENGTH_SHORT);
                t.show();
            }else if(v.getId() == R.id.btn_enable){
//                启用按钮
                btnTest.setEnabled(true);
//                btnTest.setTextColor(Color.BLUE);
                btnTest.setTextColor(Color.BLACK);

            }else if(v.getId() == R.id.btn_disable){
//                  禁用
                btnTest.setEnabled(false);
                btnTest.setTextColor(Color.GRAY);
            }else if(v.getId() == R.id.btn_test){
//                测试
                String desc = String.format("%s 您点击了按钮 ：%s", DateUtil.getNowTime(), ((Button) v).getText());
                tv_test.setText(desc);
            }
        }
    }
}
```


### 5.5 ImageView(TODO)
图像视图展示的图片通常位于res/drawable目录中，设置显示图片有两种方式：
1. AML中，通过`android:src`设置，属性名格式形如`@drawable/图片名称`；
2. java代码中`setImageResource`设置图片资源，方法参数形如`R.drawable.图片名称`.

缩放属性：ScaleType

那么如何同时展示文本和图像呢？
1. 利用LinerLayout对ImageView和TextView组合布局；
2. 通过Button的drawable***属性设置文本周围的图表。
    - drawableTop:指定文字上方的图片；
    - drawableBottom:指定文字下方的图片；
    - drawableLeft:指定文字左方的图片；
    - drawableRight:指定文字右方的图片；

### 5.6 简易计算器案例
具体见仓库代码。


## 6. Activity详解
### 6.1 Activity的启动和结束
- 从当前页面跳转到新页面，用startActivity(new Intent(源代码.this, 目标页面.class))；
- 从当前页面回到上一个页面，相当于关闭当前页面，finish()
    ```java
    intent.setClass(MainActivity.this, CalculatorActivity.class);
    startActivity(intent);
    finish();
    ```

### 6.2 生命周期
| 生命周期方法 | 作用 |
|--------------|------|
| `onCreate()` | 初始化Activity。设置布局、初始化数据、绑定视图等。 |
| `onStart()`  | 做一些界面即将显示时的准备工作。Activity 从不可见变为可见。 |
| `onResume()` | Activity 已经可见并且可以与用户交互。通常在此处开始动画、音乐等交互操作。 |
| `onPause()`  | Activity 进入暂停状态。保存未保存的状态或数据，停止动画和其他资源密集操作。 |
| `onStop()`   | Activity 不再可见。释放不再需要的资源，可以在这里做持久化数据存储。 |
| `onRestart()`| 在 Activity 被停止后再次启动之前调用。重新初始化资源。 |
| `onDestroy()`| Activity 即将被销毁。清理所有资源，释放内存，防止内存泄漏。 |

具体流程图：
![alt text](img/image-3.png)

日志输出相关博客
1. [日志输出基础知识](https://blog.csdn.net/lanlangaogao/article/details/120216228)
2. [日志使用](https://www.cnblogs.com/nuoruo/p/12865385.html)

状态切换：
![alt text](img/image-7.png)


### 6.3 启动模式

Android中的Activity启动模式（Launch Modes）定义了在启动一个Activity时系统应如何处理现有的实例。启动模式有助于管理Activity堆栈，以确保应用程序的行为符合用户期望和应用设计。

[启动模式讲解博客推荐](https://blog.csdn.net/ElisonX/article/details/80397519)

#### 6.3.1 静态设置启动模式
1. Standard（默认模式）
    - 每次启动该Activity时，系统都会创建该Activity的一个新实例，并将其推送到任务栈的顶部。
    - 适用场景：使用于大多数普通的Activity场景、适用于每次启动时都需要新的实例的情况。
    - 示例：
        ```xml
        <activity android:name=".MyActivity"
            android:launchMode="standard" />
        ```
2. SingleTop
    - 如果当前任务栈的顶部已经是该Activity的实例，则重用该实例，否则会创建新的实例。
    - 适用场景：
        - 当频繁启动Activity，但只希望栈顶保持一个实例，如浏览器中的某些页面;
        - 使用于不需要多次创建同一个Activity实例的情况。
    - 示例：
        ```xml
        <activity android:name=".MyActivity"
            android:launchMode="singleTop" />
        ```
    - 行为：如果栈顶已经是该Activity实例，系统将调用该实例的onNewIntent()方法，而不是创建新的实例。
3. SingleTask
    - 描述：系统会在任务栈中查找是否已经存在该Activity的实例。如果找到，则重用该实例并清空其上的所有其他Activity；如果没有找到，则创建新的实例。
    - 适用场景：
        - 适用于启动时需要保证任务栈中只有一个该Activity实例的情况，如应用的主屏幕或搜索界面。
        - 适用于只希望任务栈中有一个实例并避免多次启动的情况。
    - 示例：
        ```xml
        <activity android:name=".MyActivity"
            android:launchMode="singleTask" />
        ```
    - 行为：系统调用该实例的onNewIntent()方法，并清除该实例之上的所有Activity。
4. SingleInstance
    - 描述：该Activity将独立运行在一个新的任务栈中，且在整个系统中只存在该Activity的一个实例。
    - 适用场景：
        - 适用于一些全局唯一的Activity，如闹钟、来电界面等。
        - 使用于需要完全独立任务栈的情况。
    - 示例：
        ```xml
        <activity android:name=".MyActivity"
            android:launchMode="singleInstance" />
        ```
    - 行为：系统将创建一个新的任务栈，并将该Activity作为栈中的唯一Activity。

#### 6.3.2 动态设置启动模式

动态设置启动模式并不是直接改变Activity的启动模式，而是通过Intent的标志（flags）来实现类似的效果。

总结表格：


| **Intent Flag**                     | **描述**                                                                                                                   | **示例代码**                                                                                                             |
|-------------------------------------|----------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| `FLAG_ACTIVITY_NEW_TASK`            | 如果要启动的Activity不存在于当前任务中，将创建一个新的任务并将该Activity放在新任务的根部。类似于 `singleTask` 启动模式。 | ```java<br>Intent intent = new Intent(context, MyActivity.class);<br>intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br>context.startActivity(intent);<br>``` |
| `FLAG_ACTIVITY_SINGLE_TOP`          | 如果要启动的Activity已经位于任务栈的顶部，则重用该Activity实例，而不是创建新的实例。类似于 `singleTop` 启动模式。        | ```java<br>Intent intent = new Intent(context, MyActivity.class);<br>intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);<br>context.startActivity(intent);<br>``` |
| `FLAG_ACTIVITY_CLEAR_TOP`           | 如果要启动的Activity在任务栈中已经存在，则将其上的所有Activity清除，并将该Activity重新创建在栈顶。类似于 `singleTask` 启动模式。 | ```java<br>Intent intent = new Intent(context, MyActivity.class);<br>intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);<br>context.startActivity(intent);<br>```  |
| `FLAG_ACTIVITY_NO_HISTORY`          | 启动的Activity在离开后不会保留在任务栈中。                                                                                  | ```java<br>Intent intent = new Intent(context, MyActivity.class);<br>intent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);<br>context.startActivity(intent);<br>``` |
| `FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TOP` | 结合两个标志，确保Activity在新任务中运行，并清除其上的所有其他Activity。类似于 `singleTask` 启动模式。                    | ```java<br>Intent intent = new Intent(context, MyActivity.class);<br>intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);<br>context.startActivity(intent);<br>``` |

***

登录成功之后通常点击返回键，不需要再回到原来的登录界面，所以对于登录成功的activity的启动模式应该这样设置：
```java
// 登录成功之后就不需要返回到登录界面了，所以需要设置启动模式
Intent intent = new Intent(this, LoginSuccessActivity.class);
intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
```

### 6.4 如何修改默认样式（题外话）
有时候设置按钮的背景颜色不起作用，我们需要在清单文件中找到Theme.xml文件，然后将继承的父样式改一下：加上Bridge。

```XML
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
<!--    <style name="Base.Theme.Test" parent="Theme.Material3.DayNight.NoActionBar">-->
    <style name="Base.Theme.Test" parent="Theme.MaterialComponents.DayNight.DarkActionBar.Bridge">
        <!-- Customize your light theme here. -->
        <!-- <item name="colorPrimary">@color/my_light_primary</item> -->
    </style>

    <style name="Theme.Test" parent="Base.Theme.Test" />
</resources>
```


### 6.5 Intent
Intent是各个组件之间信息沟通桥梁，用于各组件之间通信，主要完成以下工作：
- 标明本次通信从哪里来，到哪里去，要怎么走；
- 发起方携带本次通信需要的数据内容，接收方从收到的意图中解析数据；
- 发起方若要判断接收方的处理结果，intent就要负责让接收方传回应答的数据内容。

参考博客：
1. [Intent详细介绍](https://blog.csdn.net/wangmx1993328/article/details/83027942)
2. [Uri对象资源定位符讲解](https://blog.csdn.net/sinat_37205087/article/details/102815247)

#### 6.5.1 显式Intent和隐式Intent
1. 显示Intent   **直接指定来源活动和目标活动，属于精准匹配**。
    - Intent的构造函数中指定
        `Intent intent = new Intent(this, ActNextActivity.class)`
    - 调用setClass方法
        ```java
        Intent intent = new Intent();
        intent.setClass(this, ActNextActivity.class);
        ```
    - 调用setComponent方法
        ```java
        Intent intent = new Intent();
        //创建包含目标活动在内的组件名称
        ComponentName conponent = new ComponentName(this, ActNextActivity.class);
        intent.setComponent(component);
        ```

2. 隐式Intent 没有明确指出要跳转的目标，只给出一个动作字符串让系统自动匹配，属于模糊匹配。
    - 通常APP不希望向外部暴露活动名称，只给出一个实现自定义好的标记穿，这样大家约定俗成按图索骥。隐式意图便起到标记过滤的作用。
    - Intent 类定义了一系列动作常量对应不同的意图：
    以下是常见的 `Activity` `Intent` `Action` 常量及其对应的常量值和描述的表格：
    | 常量名称               | 常量值                         | 意义/描述                          |
    |--------------------|------------------------------|-----------------------------------|
    | ACTION_MAIN        | android.intent.action.MAIN   | 应用程序入口                         |
    | ACTION_VIEW        | android.intent.action.VIEW   | 显示数据给用户                        |
    | ACTION_ATTACH_DATA | android.intent.action.ATTACH_DATA | 指明附加信息给其他地方的一些数据                |
    | ACTION_EDIT        | android.intent.action.EDIT   | 显示可编辑的数据                        |
    | ACTION_PICK        | android.intent.action.PICK   | 选择数据                            |
    | ACTION_CHOOSER     | android.intent.action.CHOOSER | 显示一个Activity选择器                 |
    | ACTION_GET_CONTENT | android.intent.action.GET_CONTENT | 获得内容                            |
    | ACTION_DIAL        | android.intent.action.DIAL   | 显示打电话面板                        |
    | ACTION_CALL        | android.intent.action.CALL   | 直接打电话                           |
    | ACTION_SEND        | android.intent.action.SEND   | 直接发短信                           |
    | ACTION_SENDTO      | android.intent.action.SENDTO | 选择发短信                           |
    | ACTION_ANSWER      | android.intent.action.ANSWER | 应答电话                            |
    | ACTION_INSERT      | android.intent.action.INSERT | 插入数据                            |
    | ACTION_DELETE      | android.intent.action.DELETE | 删除数据                            |
    | ACTION_RUN         | android.intent.action.RUN    | 运行数据                            |
    | ACTION_SYNC        | android.intent.action.SYNC   | 同步数据                            |


3. Uri和category
    Intent动作既可以用setAction方法指定，也可以用构造函数Intet(String action)直接生成意图对象。由于动作是模糊匹配的，需要更加详细的路径，比如仅仅知道某人住在天通苑小区，并不能直接找到他家，还得说明具体地址。**Uri和Category便是这样的路径和门类信息。Uri数据可以用构造函数Intent(String action,Uri uri)在生成对象时指定，也可以通过setData方法指定；Category可以通过addCategory方法指定。**

    `Uri` 是 Android 中表示统一资源标识符（Uniform Resource Identifier）的类，用于表示和处理资源的引用。`Uri` 类在 Android 开发中非常常见，通常用于在应用之间传递数据、访问内容提供者（Content Providers）、处理网络资源等。
    - Uri 的重要方法
        - `parse(String uriString)`: 将字符串解析为一个 `Uri` 对象。
        - `getScheme()`: 返回 URI 的方案（例如 `http`, `tel`, `mailto`）。
        - `getHost()`: 返回 URI 的主机部分。
        - `getPath()`: 返回 URI 的路径部分。
        - `getQueryParameter(String key)`: 返回 URI 中查询参数的值。

    

#### 6.5.2 Intent总结
Intent 是 Android 系统中的一个重要概念，用于在不同组件之间进行通信和交互。它表示了应用程序中执行某个动作的意图或者计划。其中有以下常见属性

1. 动作（Action）

```java
// 创建一个 Intent 对象，并指定动作为 ACTION_VIEW，用于查看指定的数据
Intent viewIntent = new Intent(Intent.ACTION_VIEW);
viewIntent.setData(Uri.parse("https://www.example.com"));
startActivity(viewIntent);
```

在这个例子中，我们创建了一个 Intent 对象，并指定了动作为 `ACTION_VIEW`，表示要查看数据。然后，我们通过 `setData()` 方法设置了要查看的数据的 URI，并调用 `startActivity()` 方法启动相应的 Activity。

2. 数据（Data）

```java
// 创建一个 Intent 对象，并指定数据为一个电话号码，动作为 ACTION_DIAL，用于拨打电话
Intent dialIntent = new Intent(Intent.ACTION_DIAL);
dialIntent.setData(Uri.parse("tel:1234567890"));
startActivity(dialIntent);
```

在这个例子中，我们创建了一个 Intent 对象，并指定了数据为一个电话号码的 URI，然后指定了动作为 `ACTION_DIAL`，表示要拨打电话。最后，我们调用 `startActivity()` 方法启动相应的 Activity。

3. 类别（Category）

```java
// 创建一个 Intent 对象，并添加类别为 DEFAULT，表示默认的操作
Intent defaultIntent = new Intent();
defaultIntent.setAction(Intent.ACTION_VIEW);
defaultIntent.addCategory(Intent.CATEGORY_DEFAULT);
defaultIntent.setData(Uri.parse("https://www.example.com"));
startActivity(defaultIntent);
```

在这个例子中，我们创建了一个 Intent 对象，并添加了类别为 `CATEGORY_DEFAULT`，表示默认的操作。然后，我们指定了动作为 `ACTION_VIEW`，并设置了要查看的数据的 URI，最后启动相应的 Activity。

4. 附加数据（Extra）

```java
// 创建一个 Intent 对象，并添加附加数据，传递用户名到下一个 Activity
Intent intent = new Intent(this, NextActivity.class);
intent.putExtra("USERNAME", "John");
startActivity(intent);
```

在这个例子中，我们创建了一个 Intent 对象，并使用 `putExtra()` 方法添加了附加数据，将用户名传递到下一个 Activity。在下一个 Activity 中，我们可以使用 `getIntent().getStringExtra("USERNAME")` 方法获取这个附加数据。

5. 标记（Flag）

```java
// 创建一个 Intent 对象，并添加标记 FLAG_ACTIVITY_NEW_TASK，表示启动一个新的任务
Intent intent = new Intent(this, MainActivity.class);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
startActivity(intent);
```

在这个例子中，我们创建了一个 Intent 对象，并使用 `setFlags()` 方法添加了标记 `FLAG_ACTIVITY_NEW_TASK`，表示启动一个新的任务。这个标记告诉系统要创建一个新的任务栈来启动 Activity。


### 6.6 Activity传送数据

Intent用Bundle对象存放待传递的数据信息。
Bundle对象操作各类数据的读写方法如图：
![alt text](img/image-8.png)

1. 向下一个Activity传送数据
    - 用Bundle对象存放信息数据；
    - 发送方设置Intent的putExtras方法，将额外数据发送；
    - 接收方调用Intent对象的getExtras方法取出消息包裹。
    - 发送方代码：
        ```java
        Intent intent = new Intent(this, ActReceiveActivity.class);
        Bundle bundle = new Bundle();
        // 创建一个新包裹
        bundle.putString("request_time", DateUtil.getNowTime());
        bundle.putString("request_content", tv_send.getText().toString());
        intent.putExtras(bundle);
        startActivity(intent);
        ```
    - 接收方代码：
        ```java
        tv_receive = findViewById(R.id.tv_receive);
        //从上一个页面传来的意图中获取快递包裹
        Bundle bundle = getIntent().getExtras();
        String request_time = bundle.getString("request_time");
        String request_content = bundle.getString("request_content");
        String desc = String.format("收到请求消息：\n请求时间为%s\n 请求内容为：%s",request_time,request_content);
        tv_receive.setText(desc);
        ```

2. 向上一个Activity传送数据
    处理下一个页面的应答数据，详细步骤如下：
    1. 上一个页面打包好请求数据，registerForActivityResult()方法来注册一个用于处理活动结果的回调函数执行跳转动作；
    2. 下一个页面接受并解析请求数据，进行相应处理；
    3. 下一个页面在返回上一个页面时，打包应答数据并调用**setResult**方法返回数据包裹；
    4. 上一个页面registerForActivityResult()方法的回调函数处理接收到的数据。

    示例代码如下:
    上一个页面的代码：
    ```java
    // 重写一下接受数据的
    register = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {
        if(result != null){
            Intent intent = result.getData();
            if(intent != null && result.getResultCode() == ActSenActivity.RESULT_OK){
                Bundle bundle = intent.getExtras();
                String request_time = bundle.getString("response_time");
                String request_content = bundle.getString("response_content");
                String desc = String.format("收到返回消息：\n应答时间为%s\n应答内容为%s",request_time,request_content);
                //显示返回详情的文字
                tv_response.setText(desc);
            }
        }
    });

    // 点击事件跳转
    public void onClick(View v) {
        Intent intent = new Intent(this, ActReceiveActivity.class);
        Bundle bundle = new Bundle();
        // 创建一个新包裹
        bundle.putString("request_time", DateUtil.getNowTime());
        bundle.putString("request_content", mRequest);
        intent.putExtras(bundle);

        // 转到下一个页面之后，也要右一个接口来更新下一个activity传过来的数据
        // startActivityForResult(); 该方法已经被弃用
        // 用全局变量register的launch方法跳转
        register.launch(intent);
        // 就不需要用这个跳转了
        //startActivity(intent);

    }

    ```

    下一个页面的代码：
    ```java
    Intent intent = new Intent();
    Bundle bundle = new Bundle();
    bundle.putString("response_time", DateUtil.getNowTime());
    bundle.putString("response_content", res);
    // 注意要将bundle放到新建的intent中
    intent.putExtras(bundle);
    setResult(Activity.RESULT_OK, intent);
    finish();
    ```

#### 6.6.1 着重分析registerForActivityResult()方法

对于以上代码：
在主活动（MainActivity）中，创建一个 ActivityResultLauncher 实例，使用 registerForActivityResult() 方法。
这个方法需要两个参数：
1. 一个 ActivityResultContract 对象，指定启动活动的类型，这里使用 new ActivityResultContracts.StartActivityForResult()。
2. 一个 ActivityResultCallback 回调对象，定义如何处理返回的结果。

在主活动中，使用 launcher.launch(intent) 启动第二个活动（SecondActivity）。

处理返回结果：
在 ActivityResultCallback 的 onActivityResult() 方法中处理返回的结果。
在 Android 中，**ActivityResultCallback 是一个接口，用于处理活动返回的结果。你需要实现 onActivityResult() 方法，系统会在活动完成并返回结果时调用这个方法。**


Lambda表达式：
JDK1.8之后引入的一种语法，他的写法是使用一个->符号，箭头将Lambda表达式分为左右两部分，左边写的是实现的这个接口中的抽象方法中的形参列表，右边就是对抽象方法的处理；
`实现的这个接口中的抽象方法中的形参列表 -> 抽象方法的处理`

例如：
```java
// 定义一个带一个参数的接口
interface MyFunction {
    void apply(String s);
}

// 使用Lambda表达式
MyFunction printFunction = (String s) -> System.out.println(s);
printFunction.apply("Hello, Lambda with parameter!"); // 输出：Hello, Lambda with parameter!

```


### 6.7 为活动补充附加信息
#### 6.7.1 利用资源文件配置字符串
资源文件配置字符串使得文本内容可以集中管理，方便统一修改和国际化处理。方法如下：

1. 在res/values/strings.xml 添加string标签： 
   ```xml
   <!-- strings.xml -->
   <resources>
       <string name="app_name">MyApp</string>
       <string name="welcome_message">Welcome to our app!</string>
       <string name="button_text">Click Me</string>
   </resources>
   ```

3. **使用字符串资源：** 在布局文件、Java 代码或其他资源文件中，可以通过 `@string/资源名称` 的方式来引用字符串资源。

   - 在布局文件中：
     ```xml
     <!-- activity_main.xml -->
     <TextView
         android:id="@+id/textView"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:text="@string/welcome_message" />
     ```
   
   - 在 Java 代码中：
    getString方法是在context类中，activity直接继承该类，所以可以直接使用该方法。
     ```java
     // MainActivity.java
     String message = getString(R.string.welcome_message);
     ```


#### 6.7.2 利用元数据传递配置信息
参考博客：
    [元数据传递配置信息](https://blog.csdn.net/Tir_zhang/article/details/126956205#:~:text=%E5%85%83%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%BB%85%E8%83%BD%E4%BC%A0%E9%80%92%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%82%E6%95%B0%EF%BC%8C%E8%BF%98%E8%83%BD%E4%BC%A0%E9%80%81%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E8%B5%84%E6%BA%90%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%E6%94%AF%E4%BB%98%E5%AE%9D%E7%9A%84%E5%BF%AB%E6%8D%B7%E5%BC%8F%E8%8F%9C%E5%8D%95%E3%80%82,%E5%88%A9%E7%94%A8%E5%85%83%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE%E5%BF%AB%E6%8D%B7%E8%8F%9C%E5%8D%95%20%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84meta-data%E6%A0%87%E7%AD%BE%E9%99%A4%E4%BA%86%E5%89%8D%E9%9D%A2%E7%9A%84name%E5%B1%9E%E6%80%A7%E5%92%8Cvalue%E5%B1%9E%E6%80%A7%EF%BC%8C%E8%BF%98%E6%8B%A5%E6%9C%89resource%E5%B1%9E%E6%80%A7%EF%BC%8C%E8%AF%A5%E5%B1%9E%E6%80%A7%E5%8F%AF%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AAXML%E6%96%87%E4%BB%B6%EF%BC%8C%E8%A1%A8%E7%A4%BA%E5%85%83%E6%95%B0%E6%8D%AE%E6%83%B3%E8%A6%81%E7%9A%84%E5%A4%8D%E6%9D%82%E4%BF%A1%E6%81%AF%E4%BF%9D%E5%AD%98%E4%BA%8EXML%E6%95%B0%E6%8D%AE%E4%B9%8B%E4%B8%AD%E3%80%82)

1. 格式
    <meta-data android:name="weather" android:value="xxx"/>

2. 什么场景需要使用？
    使用第三方SDK，需要在APP应用内使用别的APP的整合包，如使用微信登录、某某地图等。

3. 在java代码中，获取元数据信息的步骤分为下列三步：
    - 调用getPackageManager方法获得当前应用的包管理器；
    - 调用包管理器的getActivityInfo方法获得当前活动的信息对象；
    - 活动信息对象的metaData是Bundle包裹类型，调用包裹对象的getString即可获得指定名称的参数值。

元数据不仅能传递简单的字符串参数，还能传送更复杂的资源数据，如支付宝的快捷式菜单。

利用元数据配置快捷菜单
元数据的meta-data标签除了前面的name属性和value属性，还拥有resource属性，该属性可指定一个XML文件，表示元数据想要的复杂信息保存于XML数据之中。

利用元数据配置快捷菜单的步骤如下：
1. 在res/values/strings.xml添加各个菜单项名称的字符串配置
2. 创建res/xml/shortcuts.xml，在该文件中填入各组菜单项的快捷方式定义。
3. 给activity节点注册元数据的快捷菜单配置。
 例：长按应用出现快捷菜单

清单文件AndroidManifest.xml
```XML
<activity
    android:name=".ActStartActivity"
    android:exported="true">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />

        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
    <meta-data android:name="android.app.shortcuts" android:resource="@xml/shortcuts"/>
</activity>
​```新建shortcuts.xml文件用于配置快捷菜单
​```XML
<resources xmlns:android="http://schemas.android.com/apk/res/android">
    <shortcut
        android:shortcutId="first"
        android:enabled="true"
        android:icon="@mipmap/ic_launcher"
        android:shortcutLongLabel="@string/first_long"
        android:shortcutShortLabel="@string/first_short">
<!--文字太长则显示shotLabel ↑-->
<!--点击选项跳转到的页面 ↓-->
        <intent
            android:action="android.intent.action.VIEW"
            android:targetPackage="com.example.chapter2"
            android:targetClass="com.example.chapter2.ActStartActivity"/>
        <categories android:name="android.shortcut.conversation"/>
    </shortcut>
</resources>
```

运行结果：长按出现快捷菜单



## 7. java复习

### 7.1 面向对象几个重要思想（封装、继承、多态、接口）
当然，我可以帮助你总结 Java 中的封装、继承、多态和接口，并提供简单的代码示例。

1. 封装 (Encapsulation)
**封装**是将对象的状态（属性）私有化，并通过公共的方法（getter 和 setter）提供访问。

**示例**：
```java
public class Person {
    // 私有属性
    private String name;
    private int age;

    // 构造函数
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // getter 方法
    public String getName() {
        return name;
    }

    // setter 方法
    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    // 显示信息的方法
    public void displayInfo() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}
```

**说明**：
- 属性 `name` 和 `age` 被私有化，不能直接访问。
- 提供公共的 `getter` 和 `setter` 方法来访问和修改属性。

2. 继承 (Inheritance)

**继承**是指一个类（子类）继承另一个类（父类）的属性和方法，使子类能够重用父类的代码。

**示例**：
```java
// 父类
public class Animal {
    public void eat() {
        System.out.println("This animal eats food.");
    }
}

// 子类继承父类
public class Dog extends Animal {
    // 子类特有的方法
    public void bark() {
        System.out.println("The dog barks.");
    }
}

// 测试继承
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();  // 调用父类的方法
        dog.bark(); // 调用子类的方法
    }
}
```

**说明**：
- 子类 `Dog` 继承父类 `Animal`，可以直接使用父类的 `eat()` 方法。
- 子类 `Dog` 有自己的 `bark()` 方法。

3. 多态 (Polymorphism)

**多态**允许使用父类引用指向子类对象，从而调用子类的重写方法。

**示例**：
```java
// 父类
public class Animal {
    public void makeSound() {
        System.out.println("Some sound...");
    }
}

// 子类重写父类的方法
public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Bark");
    }
}

public class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Meow");
    }
}

// 测试多态
public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        myDog.makeSound(); // 输出 "Bark"
        myCat.makeSound(); // 输出 "Meow"
    }
}
```

**说明**：
- 使用父类 `Animal` 的引用指向子类对象 `Dog` 和 `Cat`。
- 调用 `makeSound()` 方法时，根据实际对象类型（`Dog` 或 `Cat`）调用相应的重写方法。

4. 接口 (Interface)

**接口**定义了一组抽象方法，任何类实现接口时，必须提供这些方法的实现。

**示例**：
```java
// 定义接口
interface Animal {
    void eat();
    void makeSound();
}

// 实现接口
public class Dog implements Animal {
    @Override
    public void eat() {
        System.out.println("Dog eats bones.");
    }

    @Override
    public void makeSound() {
        System.out.println("Dog barks.");
    }
}

public class Cat implements Animal {
    @Override
    public void eat() {
        System.out.println("Cat eats fish.");
    }

    @Override
    public void makeSound() {
        System.out.println("Cat meows.");
    }
}

// 测试接口
public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog();
        Animal cat = new Cat();

        dog.eat();       // 输出 "Dog eats bones."
        dog.makeSound(); // 输出 "Dog barks."

        cat.eat();       // 输出 "Cat eats fish."
        cat.makeSound(); // 输出 "Cat meows."
    }
}
```

**说明**：
- 接口 `Animal` 定义了两个抽象方法 `eat()` 和 `makeSound()`。
- 类 `Dog` 和 `Cat` 实现了 `Animal` 接口，并提供了这两个方法的具体实现。
- 使用接口类型的引用来调用具体实现的方法。

总结
- **封装**：通过私有属性和公共方法控制对对象数据的访问。
- **继承**：通过继承父类的属性和方法，实现代码重用。
- **多态**：通过父类引用指向子类对象，实现方法的动态调用。
- **接口**：定义一组抽象方法，类通过实现接口提供具体实现。


### 7.2 常用数据类型
1. 基本数据类型

| 数据类型  | 位数 | 默认值  | 最小值                     | 最大值                      | 示例       |
|-----------|------|---------|----------------------------|-----------------------------|------------|
| `byte`    | 8    | 0       | -128                       | 127                         | `byte b = 10;` |
| `short`   | 16   | 0       | -32,768                    | 32,767                      | `short s = 100;` |
| `int`     | 32   | 0       | -2^31                      | 2^31-1                      | `int i = 1000;` |
| `long`    | 64   | 0L      | -2^63                      | 2^63-1                      | `long l = 10000L;` |
| `float`   | 32   | 0.0f    | 1.4E-45 (最小正数)         | 3.4028235E38 (最大正数)     | `float f = 10.5f;` |
| `double`  | 64   | 0.0d    | 4.9E-324 (最小正数)        | 1.7976931348623157E308 (最大正数) | `double d = 20.5;` |
| `char`    | 16   | '\u0000'| '\u0000' (最小值)          | '\uffff' (最大值)           | `char c = 'A';` |
| `boolean` | 1    | false   | false                      | true                        | `boolean b = true;` |

2. Number和Math类

参考博客：[菜鸟教程](https://www.runoob.com/java/java-number.html)

3. String类
    参考博客：
    - [菜鸟教程String类](https://www.runoob.com/java/java-string.html)
    - [StringBuffer 和 StringBuilder 类](https://www.runoob.com/java/java-stringbuffer.html)

4. 数组
    和Number类与Math相似，一个是数据，一个是相当于工具类。
    参考博客：
    - [数组](https://www.runoob.com/java/java-array.html)
    - 表格总结：

        | 方法                | 描述                                           | 示例                                                                   |
        |---------------------|------------------------------------------------|------------------------------------------------------------------------|
        | `sort(array)`       | 对数组进行排序                                 | `Arrays.sort(numbers);`                                                |
        | `binarySearch(array, key)` | 使用二分搜索算法在数组中查找元素          | `Arrays.binarySearch(numbers, 5);`                                     |
        | `copyOf(array, length)`    | 复制数组                                  | `Arrays.copyOf(original, 5);`                                          |
        | `equals(array1, array2)`   | 比较两个数组是否相等                      | `Arrays.equals(array1, array2);`                                       |
        | `fill(array, value)`       | 用指定值填充数组                          | `Arrays.fill(numbers, 7);`                                             |
        | `toString(array)`          | 将数组转换为字符串表示形式                | `Arrays.toString(numbers);`                                            |
        | `asList(array)`            | 将数组转换为 `List`                       | `Arrays.asList(array);`                                                |

5. 日期
    1. Date 类来封装当前的日期和时间；
    2. SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。
    参考博客: [日期API](https://www.runoob.com/java/java-date-time.html)

6. 正则表达式
    参考教程：
    - [详细讲解](https://www.runoob.com/java/java-regular-expressions.html)
    - [常用表达式全集](https://www.jyshare.com/front-end/854/)

    简单总结：
    1. `^` 和 `$`
        - `^`: 匹配字符串的开始。例如，`^abc` 匹配以 "abc" 开头的字符串。
        - `$`: 匹配字符串的结束。例如，`abc$` 匹配以 "abc" 结尾的字符串。

    2. 字符簇 `[]`
        - `[]`: 表示字符簇，匹配方括号内的任意一个字符。例如，`[abc]` 匹配 "a"、"b" 或 "c" 中的任意一个。
        - `[^]`: 否定字符簇，匹配不在方括号内的任意一个字符。例如，`[^abc]` 匹配除 "a"、"b"、"c" 以外的任意一个字符。
        - `[-]`: 匹配范围内的字符。例如，`[a-z]` 匹配任何小写字母，`[0-9]` 匹配任何数字。

    3. 特殊字符 `.`
        1c"、"a-c" 等。

    4. 数量修饰符 `{}`、`*`、`+`、`?`
        - `{x}`: 匹配前面的元素恰好出现 `x` 次。例如，`a{3}` 匹配 "aaa"。
        - `{x,y}`: 匹配前面的元素至少出现 `x` 次，至多出现 `y` 次。例如，`a{2,4}` 匹配 "aa"、"aaa" 或 "aaaa"。
        - `{x,}`: 匹配前面的元素至少出现 `x` 次。例如，`a{2,}` 匹配 "aa"、"aaa"、"aaaa" 等。
        - `*`: 匹配前面的元素零次或多次（相当于 `{0,}`）。例如，`a*` 匹配 ""（空字符串）、"a"、"aa"、"aaa" 等。
        - `+`: 匹配前面的元素一次或多次（相当于 `{1,}`）。例如，`a+` 匹配 "a"、"aa"、"aaa" 等。
        - `?`: 匹配前面的元素零次或一次（相当于 `{0,1}`）。例如，`a?` 匹配 ""（空字符串）或 "a"。

    5. 具体的例子：
        - `^a.*b$`: 匹配以 "a" 开头，以 "b" 结尾的字符串，中间可以有任意字符。例如，"a123b"、"ab"。
        - `[a-zA-Z]`: 匹配任意一个字母，不区分大小写。
        - `\d{2,4}`: 匹配一个至少包含2个，至多包含4个数字的字符串。例如，"12"、"123"、"1234"。
        - `a*`: 匹配零个或多个 "a"。例如，""（空字符串）、"a"、"aaa"。
        - `a+`: 匹配一个或多个 "a"。例如，"a"、"aa"、"aaa"。
        - `a?`: 匹配零个或一个 "a"。例如，""（空字符串）或 "a"。


### 7.3 static

参考博客：
    [static用法](https://blog.csdn.net/double222222/article/details/136318553)


| 用法      | 示例                                |
|-----------|------------------------------------|
| 静态变量  | `static int count = 0;`            |
| 静态方法  | `public static void myMethod() {}` |
| 静态代码块| `static { // 初始化代码 }`         |
| 静态内部类| `static class StaticInnerClass {}` |

优点：
1. **共享数据：** 静态成员可以在多个对象之间共享数据，节省内存空间。
2. **方便访问：** 可以直接通过类名访问静态成员，无需创建类的实例，提高了代码的灵活性和可读性。
3. **节省内存：** 静态成员只会在内存中分配一次，所有对象共享同一份副本，减少了内存开销。
4. **简化代码：** 静态成员的使用简化了代码结构，提高了代码的清晰度和可维护性。


## 8. 中级控件
### 8.1 图形绘制

参考博客：
1. [图形绘制shape类型](https://blog.csdn.net/notthin/article/details/121899183)
2. [九宫格图片](https://blog.csdn.net/csdnzouqi/article/details/118891063)
3. [状态列表图形](https://blog.csdn.net/abcdefg1289/article/details/138835737)


#### 8.1.1 Shape
Shape是一种在 XML 文件中定义的通用形状。
文件位置：res / drawable / filename.xml
文件名用作资源 ID。

在 Java 中：R.drawable.filename
在 XML 中：@[package:]drawable/filename

使用：
1. shape.xml形状
```XML
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
<!--   指定内部填充颜色     -->
    <solid android:color="#ffdd66"/>
<!--    指定形状轮廓的粗细和颜色-->
    <stroke
        android:width="1dp"
        android:color="#aaaaaa"/>
<!--    指定形状四个圆角的半径-->
    <corners
        android:radius="10dp"/>
</shape>
```

2. 使用的java代码
```java
v_content.setBackgroundResource(R.drawable.shape_rect_gold);
```

#### 8.1.2 状态列表图形
常见的图形文件一般为静态图形，但有时会用到动态图形，比如按钮控件的背景在正常情况下是凸起的，在按下时是凹陷的，从按下到弹起的过程，用户便晓得点击了该按钮。根据不同的触摸情况变更图形状态，这种情况用到了Drawable 的一个子类 StateListDrawable （状态列表图形），它在 XML 文件中规定了不同状态时候所呈现的图形列表。

<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:drawable="@drawable/button_pressed" android:state_pressed="true" />
    <item android:drawable="@drawable/button_normal" />

</selector>
上述xml文件的关键点是state_pressed属性，该属性表示按下状态，值为true表示按下时显示button_pressed图像，其余情况显示button_normal图像。

![alt text](img/image-9.png)



### 8.2 选择按钮

CompoundButton类时符合按钮，由他派生而来的子类包括：复选框CheckBox、单选按钮RadioButton以及开关按钮Switch。
![alt text](img/image-10.png)

#### 8.2.1 复选框CheckBox
ndroid CheckBox (复选框) 继承自 Button ，可以说是只有两种状态的按钮 (选中或未选中状态)

可以把多个 CheckBox 放在一起实现同时选中多项，但是，记住，它们之间没有任何关系，一个的选中并不会影响另一个选中或者不选中。

CheckBox在XML属性有：
1. checked：指定按钮的勾选状态，true表示勾选，false表示没有勾选；
2. button：指定左侧勾选图标的图形资源。

在java代码中主要有四种方法：
1. setChecked：设置按钮的勾选状态；
2. setButtonDrawable：设置左侧勾选图形的图标；
3. setOnCheckedChangeListener：设置勾选状态变化的监听器；
4. isChecked：判断按钮是否勾选。

举例：
```XML
<CheckBox
    android:id="@+id/ck_system"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:minHeight="48dp"
    android:padding="5dp"
    android:text="这是系统的checkbox"
    android:textSize="30sp" />

<CheckBox
    android:id="@+id/ck_custom"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:minHeight="48dp"
    android:padding="5dp"
    android:text="这个checkBox换了图标"
    android:button="@drawable/checkbox_selector"
    android:layout_marginTop="10dp"
    android:textSize="30sp" />
```

java代码
```java
// 设置checkbox的监听
CheckBox ck_system = findViewById(R.id.ck_system);
CheckBox ck_custom = findViewById(R.id.ck_custom);

ck_system.setOnCheckedChangeListener(this);
ck_custom.setOnCheckedChangeListener(this);

@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
    String desc = String.format("您%s了这个checkbox", isChecked ? "勾选" : "取消勾选");
    buttonView.setText(desc);
}

```

#### 8.2.2 开关按钮Switch

参考博客：
1. [开关按钮教程](https://blog.csdn.net/qq_34215018/article/details/127690304)

Switch开关按钮属性介绍
- textOn：开关按钮打开时显示的文字。
- textOff：开关按钮关闭时显示的文字。
- thumb：开关按钮上原型滑块的样式，自定义样式时需要设置此样式。
- track：开关按钮下面导轨的样式，自定义样式时需要设置此样式。
- switchTextAppearance：设置文本的风格，可以用来设置开关两种状态下的文本样式。
- checked：设置初始选中状态
- showText：设置是否显示开关上的文字（android系统中默认不显示）



#### 8.2.3 单选按钮RadioButton

单选按钮要在一组按钮中选择其中一项，并且不能多选，这要求有一个容器确定这一组按钮的范围，这个容器就是单选组RadioGroup.

RadioGroup本质是一个布局（呈现水平排布），同一组的RadioButton都要放在同一个RadioGroup节点下面，也可以放置其他组件。

xml代码：
```xml
<RadioGroup
    android:id="@+id/rg_gender"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal">
    <RadioButton
        android:id="@+id/rb_male"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="男"/>
    <RadioButton
        android:id="@+id/rb_female"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="女"/>
</RadioGroup>
```

java代码：
```java
RadioGroup rb_gender = findViewById(R.id.rg_gender);
rb_tvresult = findViewById(R.id.rb_tvresult);
rb_gender.setOnCheckedChangeListener(this);

@Override
public void onCheckedChanged(RadioGroup group, int checkedId) {
    if (checkedId == R.id.rb_male){
        rb_tvresult.setText("你是一个帅气的男孩");
    }else if( checkedId == R.id.rb_female){
        rb_tvresult.setText("你是一个可爱的女孩");
    }
}
```

### 8.3 文本输入-编辑框EditText

EditText(输入框)，是安卓开发布局时比较常用的控件，和TextView非常类似，最大的区别是：EditText可以接受用户输入。

1. `EditText`控件xml中常见属性：

    | 属性 | 说明 |
    |------|------|
    | `android:inputType=""` | 输入内容的类型（`number` - 数字；`numberDecimal` - 浮点数） |
    | `android:capitalize=""` | 英文大写设置（`characters` - 每个英文字母都大写；`sentences` - 仅第一个字母大写；`words` - 每一个单词首字母大写，用空格区分单词） |
    | `android:minLines=""` | 最小行数 |
    | `android:maxLines=""` | 最大行数 |
    | `android:singleLine=""` | 单行，不换行（为`true`时，单行显示） |
    | `android:maxLength=""` | 输入字数限制 |
    | `android:password=""` | 文字为密码形式，样式： · · · · · · |
    | `android:phoneNumber=""` | 输入电话号码（为`true`时，起效） |

2. java中主要函数使用：

    | 函数 | 说明 |
    |------|------|
    | `getText()` | 获取输入框的文本内容，返回 `Editable` 对象。 |
    | `setText(CharSequence text)` | 设置输入框的文本内容。 |
    | `getText().toString()` | 获取输入框的文本内容，返回 `String` 对象。 |
    | `setOnFocusChangeListener` | 监听组件。 |
    | `getInputType()` | 获取当前的输入类型。 |
    | `requestFocus()` | 请求获取焦点。 |

3. 代码举例：监听号码，判断密码格式：
    ```java
    // 声明周期函数
    et_phone = findViewById(R.id.et_phone);
    et_pwd = findViewById(R.id.et_password);
    et_pwd.setOnFocusChangeListener(this);
    findViewById(R.id.btn_login).setOnClickListener(this);

    // 监听事件
    public void onFocusChange(View v, boolean hasFocus) {
        if (hasFocus) {
            String phone = et_phone.getText().toString();
            // 手机号码不足11位
            if ( TextUtils.isEmpty(phone) || phone.length() < 11) {
                // 手机号码编辑框请求焦点，把光标移到手机号码编辑处
                et_phone.requestFocus();
                // 提示
                Toast.makeText(this,"请输入11位手机号",Toast.LENGTH_SHORT).show();
            }
        }
    }

    // 密码检测函数（）正则表达式
    // 设置判断密码格式的正则表达式
    private boolean isValidPassword(String password) {
        // 正则表达式：至少8个字符，包含大小写字母和数字
        String regex = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,}$";
        Pattern pattern = Pattern.compile(regex);
        return !TextUtils.isEmpty(password) && pattern.matcher(password).matches();
    }

    ```



### 8.4 对话框
#### 8.4.1 提醒对话框AlertDialog

1. XML设置AlertDialog

    | 属性 | 说明 |
    |------|------|
    | `android:layout_width` | 对话框宽度，如 `match_parent` 或 `wrap_content`。 |
    | `android:layout_height` | 对话框高度，如 `match_parent` 或 `wrap_content`。 |
    | `android:background` | 背景样式，可以使用颜色、图片等。 |
    | `android:gravity` | 内容对齐方式，如 `center`、`top`、`bottom`。 |

2. Java函数

    | 方法 | 说明 |
    |------|------|
    | `AlertDialog.Builder(Context context)` | 构造AlertDialog的Builder对象。 |
    | `setTitle(CharSequence title)` | 设置对话框标题。 |
    | `setMessage(CharSequence message)` | 设置对话框消息内容。 |
    | `setPositiveButton(CharSequence text, DialogInterface.OnClickListener listener)` | 设置对话框的确认按钮及点击事件。 |
    | `setCancelable(boolean cancelable)` | 设置是否可以通过点击对话框外部区域或返回键关闭对话框。 |
    | `create()` | 创建AlertDialog对象。 |
    | `show()` | 显示AlertDialog对话框。 |


3. 代码示例：
**XML布局文件：**
```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">

    <TextView
        android:id="@+id/text_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="This is a dialog message."
        android:textSize="18sp"
        android:textColor="@android:color/black" />

</LinearLayout>
```

**Java代码示例：**
```java
// 创建AlertDialog的Builder对象
AlertDialog.Builder builder = new AlertDialog.Builder(context);

// 设置对话框标题
builder.setTitle("Dialog Title");

// 设置对话框消息内容
builder.setMessage("Dialog message content.");

// 设置确认按钮及点击事件
builder.setPositiveButton("OK", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        // 处理确认按钮点击事件
        Toast.makeText(context, "OK clicked", Toast.LENGTH_SHORT).show();
    }
});

// 设置取消按钮及点击事件
builder.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        // 处理取消按钮点击事件
        Toast.makeText(context, "Cancel clicked", Toast.LENGTH_SHORT).show();
    }
});

// 设置是否可以通过点击对话框外部区域或返回键关闭对话框
builder.setCancelable(true);

// 创建并显示AlertDialog
AlertDialog alertDialog = builder.create();
alertDialog.show();
```


#### 8.4.2 日期对话框DatePickerDialog

`DatePicker` 是一个用于选择日期的控件，通常嵌入在布局文件中。

1. XML属性
    | 属性                         | 说明                                            |
    |-----------------------------|-------------------------------------------------|
    | `android:year`              | 默认显示的年份。                                |
    | `android:month`             | 默认显示的月份（0-11）。                        |
    | `android:dayOfMonth`        | 默认显示的日期。                                |
    | `android:calendarViewShown` | 是否显示日历视图，布尔值。                      |
    | `android:spinnersShown`     | 是否显示滚轮视图，布尔值。                      |

    - XML代码
        ```xml
        <DatePicker
            android:id="@+id/datePicker"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:year="2023"
            android:month="5"
            android:dayOfMonth="15"
            android:calendarViewShown="true" />
        ```

2. Java使用
    | 方法                                   | 说明                                            |
    |----------------------------------------|-------------------------------------------------|
    | `getYear()`                            | 获取当前选中的年份。                            |
    | `getMonth()`                           | 获取当前选中的月份（0-11）。                    |
    | `getDayOfMonth()`                      | 获取当前选中的日期。                            |
    | `setMinDate(long minDate)`             | 设置可选的最小日期，以毫秒为单位。              |
    | `setMaxDate(long maxDate)`             | 设置可选的最大日期，以毫秒为单位。              |

    - Java示例
        ```java
        DatePicker datePicker = findViewById(R.id.datePicker);
        datePicker.init(2023, 5, 15, new DatePicker.OnDateChangedListener() {
            @Override
            public void onDateChanged(DatePicker view, int year, int monthOfYear, int dayOfMonth) {
                // 处理日期变化事件
                Log.d("DatePicker", "Selected date: " + year + "/" + (monthOfYear + 1) + "/" + dayOfMonth);
            }
        });
        ```



`DatePickerDialog` 是一个对话框形式的日期选择控件。

1. Java使用

    | 方法                                   | 说明                                            |
    |----------------------------------------|-------------------------------------------------|
    | `DatePickerDialog(Context context, DatePickerDialog.OnDateSetListener listener, int year, int month, int dayOfMonth)` | 构造函数，创建一个DatePickerDialog。|
    | `show()`                               | 显示对话框。                                    |
    | `dismiss()`                            | 关闭对话框。                                    |

    - Java代码：
        ```java
        // 创建DatePickerDialog的日期设置监听器
        DatePickerDialog.OnDateSetListener dateSetListener = new DatePickerDialog.OnDateSetListener() {
            @Override
            public void onDateSet(DatePicker view, int year, int month, int dayOfMonth) {
                // 处理日期选择事件
                Log.d("DatePickerDialog", "Selected date: " + year + "/" + (month + 1) + "/" + dayOfMonth);
            }
        };

        // 获取当前日期
        Calendar calendar = Calendar.getInstance();
        int year = calendar.get(Calendar.YEAR);
        int month = calendar.get(Calendar.MONTH);
        int day = calendar.get(Calendar.DAY_OF_MONTH);

        // 创建DatePickerDialog
        DatePickerDialog datePickerDialog = new DatePickerDialog(this, dateSetListener, year, month, day);

        // 显示DatePickerDialog
        datePickerDialog.show();
        ```


#### 8.4.3 时间对话框

`TimePicker` 是一个用于选择时间的控件，通常嵌入在布局文件中。

1. XML属性
    | 属性                         | 说明                                            |
    |-----------------------------|-------------------------------------------------|
    | `android:hour`              | 设置默认显示的小时（24小时制）。                 |
    | `android:minute`            | 设置默认显示的分钟。                            |
    | `android:is24HourView`      | 是否使用24小时制，布尔值。                      |
    | `android:timePickerMode`    | 设置时间选择模式（spinner或clock）。            |

    - XML示例
        ```xml
        <TimePicker
            android:id="@+id/timePicker"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:hour="14"
            android:minute="30"
            android:is24HourView="true" />
        ```


`TimePickerDialog` 是一个对话框形式的时间选择控件。

1. Java使用
    | 方法                                   | 说明                                            |
    |----------------------------------------|-------------------------------------------------|
    | `TimePickerDialog(Context context, TimePickerDialog.OnTimeSetListener listener, int hourOfDay, int minute, boolean is24HourView)` | 构造函数，创建一个TimePickerDialog。|
    | `show()`                               | 显示对话框。                                    |
    | `dismiss()`                            | 关闭对话框。                                    |

    - Java示例

        ```java
        // 组件的生命周期函数中
        findViewById(R.id.btn_time_selector).setOnClickListener(this);
        tv_time = findViewById(R.id.tv_timeshow);

        @Override
        public void onClick(View v) {
            if (v.getId() == R.id.btn_date_timeok){
                String desc = String.format("您选择的时间是%d时%d分",tp_time.getHour(), tp_time.getMinute());
                tv_time.setText(desc);
            }else if (v.getId() == R.id.btn_time_selector){
                // 获取当前时间
                Calendar calendar = Calendar.getInstance();
                int hour = calendar.get(Calendar.HOUR_OF_DAY);
                int minute = calendar.get(Calendar.MINUTE);
                // 构建时间对话框
                TimePickerDialog dialog = new TimePickerDialog(this,this, hour, minute, true);

                dialog.show();
            }

        }

        @Override
        public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
            String desc = String.format("您选择的时间是%d时%d分",hourOfDay, minute);
            tv_time.setText(desc);
        }

        ```


### 8.5 登录界面

#### 8.5.1 功能分析

1. 密码登录
    - ![alt text](img/Screenshot_20240615_224918.png)
2. 验证码登录
    - ![alt text](img/Screenshot_20240615_225021.png)
3. 忘记密码——重置密码
    - ![alt text](img/Screenshot_20240615_225120.png)
4. 记住密码
5. 登录成功


#### 8.5.2 细节实现

1. 密码登录和验证码登录的切换
    - 首先需要监听单选框整体的点击事件，判断是否切换登录功能；
    - 密码登录是默认界面；
    
    ```java
    // 全局变量
    private RadioButton rb_password, rb_verifycode;

    // 生命周期oncreate函数
    // 在单选组件里面设置事件监听
    RadioGroup rb_login = findViewById(R.id.rb_login);
    // 设置监听器
    rb_login.setOnCheckedChangeListener(this);
    rb_password = findViewById(R.id.rb_password);
        rb_verifycode = findViewById(R.id.rb_verifycode);
    
    // 单选框设置的点击事件监听
    @Override
    public void onCheckedChanged(RadioGroup group, int checkedId) {
        if (checkedId == R.id.rb_password) {
            tv_password.setText(getString(R.string.login_password));
            et_password.setHint(getString(R.string.input_password));
            btn_forget.setText(getString(R.string.forget_password));
            ck_remember.setVisibility(TextView.VISIBLE);
        }else if (checkedId == R.id.rb_verifycode) {
            tv_password.setText(getString(R.string.verifycode));
            et_password.setHint(getString(R.string.get_verifycode));
            btn_forget.setText(getString(R.string.get_verifycode));
            ck_remember.setVisibility(TextView.GONE);
        }
    }

    ```


2. 文本事件监听
    - 当文本编辑框的内容达到最大长度，自动收起键盘；
    - 这里需要针对每一个文本编辑框设置监听事件`addTextChangedListener()`
    - 监听事件需要使用系统的输入法管理器，这里可以包装成一个类进行使用。
    - ViewUtil类
        ```java
        package com.example.myapplication.Utils;

        import android.app.Activity;
        import android.content.Context;
        import android.view.View;
        import android.view.inputmethod.InputMethodManager;

        public class ViewUtil {
            public static void hideOneInputMethod(Activity act, View v){
                // 从系统服务中获取输入法管理器
                InputMethodManager imm = (InputMethodManager) act.getSystemService(Context.INPUT_METHOD_SERVICE);
                // 关闭屏幕上面的输入法键盘
                imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
            }

        }
        ```
    - activity的java代码
        ```java
        // 全局变量
        private EditText et_password,et_phone;

        // 生命周期Oncreate函数
        // 设置文本事件监听
        et_phone = findViewById(R.id.et_login_phone);
        et_phone.addTextChangedListener(new HideTextWatcher(et_phone, 11));
        et_password.addTextChangedListener(new HideTextWatcher(et_password, 6));

        // 定义生命HideTextWatcher内部类
        // 输入到达长度之后自动隐藏
        private class HideTextWatcher implements TextWatcher {
            private EditText mView;
            private int mMaxLength;
            public HideTextWatcher(EditText v, int maxLength) {
                mView = v;
                mMaxLength = maxLength;
            }

            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {

            }

            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {

            }

            @Override
            public void afterTextChanged(Editable s) {
                if (s.toString().length() == mMaxLength){
                    ViewUtil.hideOneInputMethod(LoginMainActivity.this,mView);
                }

            }
        }

        ```

3. 获取验证码和忘记密码
    - 这里仅仅是简单的本地随机生成验证码，并没有向外部请求验证码；
    - 由于验证码登录和密码登录的右侧按钮是同一个，所以需要在按钮点击事件中根据单选框的密码登录和验证码登录中哪一个选中（isChecked）；
    - 在获取验证码时随机生成6位验证码，弹出提醒框；
    - 在点击忘记密码按钮之后，需要进行页面跳转，同时还需要实现两个页面之间的数据传输：
        - 登录界面向忘记密码页面传送用户的号码；
            - 使用registerForActivityResult接口；
        - 忘记密码界面向登陆页面传送修改好的密码，也就是实现重置密码。

    ```java
    // 全局变量
    private Button btn_forget, btn_login;

    // 生命周期Oncreate函数
    btn_forget = findViewById(R.id.btn_forget);
    btn_forget.setOnClickListener(this);
    // 忘记密码界面和登录界面之间的数据传递
    register = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), new ActivityResultCallback<ActivityResult>() {
        @Override
        public void onActivityResult(ActivityResult result) {
            Intent intent = result.getData();
            if (intent != null && result.getResultCode() == LoginMainActivity.RESULT_OK){
                mPassword = intent.getStringExtra("new_password");
            }
        }
    });
    

    // 点击事件
    String phone = et_phone.getText().toString();
    if(v.getId() == R.id.btn_forget){
        // 选择密码方式校验，此时点击按钮是忘记密码，所以点击之后跳转到找回密码页面
        if (rb_password.isChecked()){
            // 携带手机号码跳转到忘记密码页面
            Intent intent = new Intent(LoginMainActivity.this, LoginForgetActivity.class);
            intent.putExtra("phone", phone);
            register.launch(intent);
        } else if (rb_verifycode.isChecked()) {
            // 生成6位随机验证码
            mVerifycode = String.format("%06d", new Random().nextInt(999999));
            // 弹出提醒对话框，提示用户记住六位验证码
            AlertDialog.Builder builder = new AlertDialog.Builder(this);
            builder.setTitle("请记住验证码");
            builder.setMessage("手机号"+phone+",本次验证码是"+mVerifycode+"请输入验证码");
            AlertDialog dialog = builder.create();
            dialog.show();
        }
    }

    ```


4. 登录按钮
    - 判断密码是否正确、电话号码是否正确；
    - 跳转到主页；
    - 注意要设置登录界面的启动模式；
    - activity的java代码
        ```java
        // 全局变量
        private Button btn_forget, btn_login;
        // 生命周期Oncreate函数
        // 登录按钮的事件监听
        btn_login = findViewById(R.id.btn_login_demo);
        btn_login.setOnClickListener(this);

        //点击事件监听
        if (v.getId() == R.id.btn_login_demo) {
            // 密码登录界面
            if (rb_password.isChecked()){
                if (!mPassword.equals(et_password.getText().toString())){
                    Toast.makeText(this,"请输入正确密码",Toast.LENGTH_SHORT).show();
                    return;
                }
                // 登录成功
                LoginSuccess();
            } else if (rb_verifycode.isChecked()) {     // 验证码登录
                if (!mVerifycode.equals(et_password.getText().toString())){
                    Toast.makeText(this,"请输入正确验证码",Toast.LENGTH_SHORT).show();
                    return;
                }

                // 登录成功
                LoginSuccess();
            }
        }

        // LoginSuccess函数
        // 登录成功，跳转到新页面
        private void LoginSuccess() {
            // 登录成功之后就不需要返回到登录界面了，所以需要设置启动模式
            Intent intent = new Intent(this, LoginSuccessActivity.class);
            intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
            intent.putExtra("username", et_phone.getText().toString());
            startActivity(intent);
        }

        ```
    
5. 忘记密码界面之将新密码传送到登录界面
    - 判断两次密码是否一致；
    - 子界面传数据到父界面步骤：
        - 用Intent在组件之间传递信息
        - setResult(Activity.RESULT_OK, intent);
        - 结束界面；
    - 父界面中用`registerForActivityResult`接口的回调函数实现数据接收和处理。

    ```java
    if (v.getId() == R.id.btn_code_confirm) {
        // 判断密码长度
        String newPwd1 = etPassord1.getText().toString();
        String newPwd2 = etPassord2.getText().toString();
        // Toast.makeText(this, "hhh",Toast.LENGTH_SHORT).show();
        if (newPwd1.length() < 6){
            Toast.makeText(this, "请输入正确的密码",Toast.LENGTH_SHORT).show();
            return;
        }

        if (!newPwd1.equals(newPwd2)){
            Toast.makeText(this, "两次输入密码不一致",Toast.LENGTH_SHORT).show();
            return;
        }

        if (!mVerifycode.equals(et_verifycode.getText().toString())){
            Toast.makeText(this, "验证码输入不正确",Toast.LENGTH_SHORT).show();
            return;
        }

        // 修改密码，把修改好的密码返回给上一个页面
        Intent intent = new Intent();
        intent.putExtra("new_password",newPwd1);
        setResult(Activity.RESULT_OK, intent);
        // 弹出提示信息
        // 弹出提醒对话框，提示用户记住六位验证码
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle("密码修改成功");
        builder.setMessage("请返回到登录页面");
        // 返回登录界面
        builder.setPositiveButton("返回", new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                finish();
            }
        });
        AlertDialog dialog = builder.create();
        dialog.show();
    }

    ```

6. 记住密码
    - 选中记住密码后，将相关的数据存放在SharedPerferences中
    ```java
    // 生命周期Oncreate
    // 记住密码
    preferences = getSharedPreferences("config", Context.MODE_PRIVATE);
    reload();
    // 登录按钮点击事件监听
    if (ck_remember.isChecked()){
        SharedPreferences.Editor editor = preferences.edit();
        editor.putString("phone", et_phone.getText().toString());
        editor.putString("password", et_password.getText().toString());
        editor.putBoolean("isRemember", ck_remember.isChecked());
        editor.commit();
    }

    // reload函数
    private void reload() {
        boolean isChecked = preferences.getBoolean("isRemember", false);
        if (isChecked){
            String phone, password;
            phone = preferences.getString("phone", "");
            password = preferences.getString("password", "");
            et_phone.setText(phone);
            et_password.setText(password);
            ck_remember.setChecked(isChecked);
        }
    }

    ```



## 9. 数据存储
### 9.1 共享参数SharedPerences

SharedPreferences 是一种轻量级的数据存储方式，用于保存简单的键值对数据，适合存储少量的配置参数或状态信息，如用户设置、应用配置等。SharedPreferences 数据存储在应用的私有目录下，因此默认情况下只有本应用可以访问这些数据。

使用场景：
1. 简单且孤立的数据，若是复杂且相互有关的数据，需要存放在数据库中。
2. 文本形式的数据。二进制数据需要存放在文件中。
3. 需要持久化存储的数据，在app推出之后再次启动时，之前保存的数据仍然有效。

实际开发中，共享参数经常存储的数据优APP的个性化配置信息、用户使用app的行为信息、临时需要保存的片段信息。


总结表格

| 方法                                | 说明                                        |
|-------------------------------------|---------------------------------------------|
| `getSharedPreferences(name, mode)`  | 获取`SharedPreferences`对象。                 |
| `getPreferences(mode)`              | 获取默认`SharedPreferences`对象（仅限Activity或Context）。|
| `putString(key, value)`             | 存储字符串。                                |
| `putInt(key, value)`                | 存储整数。                                  |
| `putBoolean(key, value)`            | 存储布尔值。                                |
| `putFloat(key, value)`              | 存储浮点数。                                |
| `putLong(key, value)`               | 存储长整型。                                |
| `apply()`                           | 异步提交编辑器内容。                         |
| `commit()`                          | 同步提交编辑器内容。                         |
| `getString(key, default)`           | 读取字符串。                                |
| `getInt(key, default)`              | 读取整数。                                  |
| `getBoolean(key, default)`          | 读取布尔值。                                |
| `getFloat(key, default)`            | 读取浮点数。                                |
| `getLong(key, default)`             | 读取长整型。                                |


举例代码：
```java
// 全局变量
private SharedPreferences preferences;
// 生命周期Oncreate函数
// 获取共享参数对象
preferences = getSharedPreferences("config", Context.MODE_PRIVATE);
reload();
// 点击事件监听函数
String name, age, height, weight;
name = et_name.getText().toString();
age = et_age.getText().toString();
height = et_height.getText().toString();
weight = et_weight.getText().toString();

// 将数据存放到共享参数中
SharedPreferences.Editor editor = preferences.edit();
editor.putString("name", name);
editor.putInt("age", Integer.parseInt(age));
editor.putFloat("height", Float.parseFloat(height));
editor.putFloat("weight", Float.parseFloat(weight));
editor.putBoolean("married", ck_married.isChecked());
// 提交
editor.apply();

// reload函数
String name;
name = preferences.getString("name", null);

if(name != null){

    int age = preferences.getInt("age", 0);
    float weight = preferences.getFloat("weight", 0);
    float height = preferences.getFloat("height", 0);
    boolean isMarried = preferences.getBoolean("married", false);

    et_name.setText(name);
    et_age.setText(String.valueOf(age));
    et_height.setText(String.format("%.2f",height));
    et_weight.setText(String.format("%.2f",weight));
    ck_married.setChecked(isMarried);
}
```

其中SharedPreference数据保存在xml文件中：位置在Device Explore的data/data/包名/Shared_prefs文件夹中：
![alt text](img/image-11.png)


### 9.2 数据库SQLite

SQLite 是一个开源的嵌入式关系型数据库，广泛用于移动应用程序中。它的轻量级和无需服务器的特性使其成为 Android 应用程序中持久化数据存储的首选。

SQL（结构化查询语言）用于管理和操作关系数据库。主要分为三类：数据定义语言（DDL）、数据操作语言（DML）和数据控制语言（DCL）。以下时常用SQL语句用法总结：


| 操作         | SQL 语句                                  | 示例                                              |
|--------------|-------------------------------------------|---------------------------------------------------|
| 创建表格     | `CREATE TABLE`                            | `CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, email TEXT UNIQUE, age INTEGER);` |
| 删除表格     | `DROP TABLE`                              | `DROP TABLE users;`                               |
| 添加列       | `ALTER TABLE ADD`                         | `ALTER TABLE users ADD address TEXT;`             |
| 删除列       | `ALTER TABLE DROP COLUMN`                 | `ALTER TABLE users DROP COLUMN address;`          |
| 插入数据     | `INSERT INTO ... VALUES`                  | `INSERT INTO users (name, email, age) VALUES ('John Doe', 'john@example.com', 30);` |
| 查询数据     | `SELECT ... FROM ... WHERE`               | `SELECT name, email FROM users WHERE age > 25;`   |
| 更新数据     | `UPDATE ... SET ... WHERE`                | `UPDATE users SET age = 31 WHERE id = 1;`         |
| 删除数据     | `DELETE FROM ... WHERE`                   | `DELETE FROM users WHERE id = 1;`                 |
| 授权权限     | `GRANT ... ON ... TO`                     | `GRANT SELECT ON users TO john;`                  |
| 撤销权限     | `REVOKE ... ON ... FROM`                  | `REVOKE SELECT ON users FROM john;`               |


#### 9.2.1 数据库管理器SQLiteDatabase

`SQLiteDatabase` 是一个用于管理 SQLite 数据库的类。它提供了一些方法来执行 SQL 操作，如创建、读取、更新和删除（CRUD）操作。在实际开发中，通常是在main目录中新建一个database目录，存放数据库管理类。


主要方法及其作用总结表格

1. 管理类——数据库层面操作
    
| 方法                 | 作用                                                                                         | 参数及解释                                                                 |
|----------------------|----------------------------------------------------------------------------------------------|---------------------------------------------------------------------------|
| `getReadableDatabase`| 获取一个只读的数据库对象，用于查询操作。                                                       | 无参数。                                                                  |
| `getWritableDatabase`| 获取一个可读写的数据库对象，用于插入、更新、删除操作。                                         | 无参数。                                                                  |
| `close`              | 关闭数据库连接，释放资源。                                                                   | 无参数。                                                                  |
| `execSQL`            | 执行一条SQL语句，可以用来执行非查询操作，如创建表、删除表、插入数据等。                        | `sql`：要执行的SQL语句<br>`bindArgs`：可选，绑定参数。                              |
| `rawQuery`           | 执行一条SQL查询语句，返回一个Cursor对象，用于读取查询结果。                                    | `sql`：要执行的SQL查询语句<br>`selectionArgs`：查询语句中的参数。                       |

2. 事务类

| 方法                 | 作用                                                                                         | 参数及解释                                                                 |
|----------------------|----------------------------------------------------------------------------------------------|---------------------------------------------------------------------------|
| `beginTransaction`   | 开始一个数据库事务。                                                                         | 无参数。                                                                  |
| `setTransactionSuccessful` | 标记事务已经成功，只有调用此方法后事务的更改才会被提交。                                   | 无参数。                                                                  |
| `endTransaction`     | 结束一个事务，根据是否调用`setTransactionSuccessful`决定是否提交事务。                        | 无参数。                                                                  |


3. 数据管理类
| 方法                      | 作用                                                                                         | 参数及解释                                                                 |
|---------------------------|----------------------------------------------------------------------------------------------|---------------------------------------------------------------------------|
| `insert`                  | 插入一条记录到指定表中。                                                                     | `table`：表名<br>`nullColumnHack`：可选，列为空时使用的替代值<br>`values`：ContentValues对象，包含要插入的列和对应值。 |
| `insertOrThrow`           | 插入一条记录到指定表中，如果失败则抛出异常。                                                 | `table`：表名<br>`nullColumnHack`：可选，列为空时使用的替代值<br>`values`：ContentValues对象，包含要插入的列和对应值。 |
| `update`                  | 更新表中的记录。                                                                             | `table`：表名<br>`values`：ContentValues对象，包含要更新的列和对应值<br>`whereClause`：WHERE子句<br>`whereArgs`：WHERE子句中的参数。 |
| `delete`                  | 从表中删除记录。                                                                             | `table`：表名<br>`whereClause`：WHERE子句<br>`whereArgs`：WHERE子句中的参数。  |
| `query`                   | 查询表中的记录，返回一个Cursor对象。                                                         | `distinct`：是否返回唯一值<br>`table`：表名<br>`columns`：要查询的列<br>`selection`：WHERE子句<br>`selectionArgs`：WHERE子句中的参数<br>`groupBy`：GROUP BY子句<br>`having`：HAVING子句<br>`orderBy`：ORDER BY子句<br>`limit`：查询结果限制。 |
| `compileStatement`        | 预编译一条SQL语句，返回一个SQLiteStatement对象，用于重复执行SQL语句。                          | `sql`：要预编译的SQL语句。                                                 |
| `beginTransactionNonExclusive` | 开始一个非独占事务，可以允许其他线程并发读操作。                                            | 无参数。                                                                  |
| `yieldIfContendedSafely`  | 如果当前事务占用数据库时间过长，允许其他线程获得数据库的短暂使用权。                          | `sleepAfterYieldDelay`：睡眠时间，单位为毫秒。                              |
| `getPath`                 | 获取数据库文件的路径。                                                                       | 无参数。                                                                  |


#### 9.2.2 数据库帮助器SQLiteOpenHelper

SQLiteOpenHelper：是一个辅助类，用于管理数据库的创建和版本控制。它简化了数据库创建、升级和打开的操作。SQLiteOpenHelper 会在需要时自动创建或更新数据库，并提供一个可以操作的 SQLiteDatabase 对象。

使用步骤：
1. 新建一个继承自SQLiteOpenHelper的数据库操作类，提示重写onCreate和onUpgrade两个方法；
2. 封装保证数据库的必要方法；
3. 提供对表记录进行增加、删除、修改、查询的操作方法。


以下是增删查改的具体步骤：
1. 创建数据库表
    - 在 `onCreate` 方法中执行 SQL 语句创建数据库表。
    - 指定表名和字段，并确保每个字段具有适当的数据类型和约束（如 PRIMARY KEY、AUTOINCREMENT 等）。

2. 插入数据（增）
    - 提供一个方法，接收数据对象作为参数。
    - 在方法内部使用 `SQLiteDatabase` 对象的 `insert` 方法将数据插入到数据库表中。
    - 使用 `ContentValues` 对象将数据包装成键值对形式，其中键是列名，值是要插入的数据。

3. 查询数据（查）
    - 提供一个方法来查询数据库中的数据。
    - 使用 `SQLiteDatabase` 对象的 `query` 方法执行查询操作。
    - 指定查询的表名、要返回的列、查询条件（如 WHERE 子句）、条件参数（如果有的话）、分组方式、分组条件、排序方式等。
    - 查询结果通常以 `Cursor` 对象的形式返回，通过遍历 `Cursor` 可以获取每一行的数据。

4. 更新数据（改）
    - 提供一个方法来更新数据库中的数据。
    - 使用 `SQLiteDatabase` 对象的 `update` 方法。
    - 指定要更新的表名、新的数据（使用 `ContentValues` 包装）、更新条件（如 WHERE 子句）、条件参数（如果有的话）。
    - 返回更新的行数，表示受影响的行数。

5. 删除数据（删）
    - 提供一个方法来删除数据库中的数据。
    - 使用 `SQLiteDatabase` 对象的 `delete` 方法。
    - 指定要删除的表名、删除条件（如 WHERE 子句）、条件参数（如果有的话）。
    - 返回删除的行数，表示受影响的行数。


代码讲解举例：
1. database文件夹中的UserDBHelper.java
    ```java
    // 类定义
    public class UserDBHelper extends SQLiteOpenHelper {}

    // 全局变量
    private static final String DB_NAME = "user.db";
    private static final String TABLE_NAME = "user_info";
    private static final int DB_VERSION = 1;
    private static UserDBHelper mHelper = null;         // 单例模式
    // 数据库的读写需要基于锁来保证安全性，所以先创建两个实例
    private SQLiteDatabase mRDB = null;
    private SQLiteDatabase mWDB = null;

    // 继承之后要重写的类
    // 父类
    public UserDBHelper(Context context) {
        super(context, DB_NAME, null, DB_VERSION);
    }
    // 在生命周期onCreate创建数据库
    public void onCreate(SQLiteDatabase db) {
        String sql = "CREATE TABLE IF NOT EXISTS " + TABLE_NAME + " (" +
                "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL," +
                " name VARCHAR NOT NULL," +
                " age INTEGER NOT NULL," +
                " height LONG NOT NULL," +
                " weight FLOAT NOT NULL," +
                " married INTEGER NOT NULL);";
        db.execSQL(sql);
    }
    // 数据库版本更新之后进行的操作
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

    }

    // 利用单例模式获取数据库帮助器的唯一实例
    // 以后请补充上同步快处理，加锁，考虑并发问题
    public static UserDBHelper getInstance(Context context){
        if (mHelper == null){
            mHelper =new UserDBHelper(context);
        }
        return mHelper;
    }

    // 打开这个帮助管理类的读数据库、写数据库、关闭数据库
    // 打开数据库的读连接
    public SQLiteDatabase openReadLink(){
        if (mRDB == null || !mRDB.isOpen()){
            mRDB = mHelper.getReadableDatabase();
        }
        return mRDB;
    }

    // 打开数据库的写连接
    public SQLiteDatabase openWriteLink(){
        if (mWDB == null || !mWDB.isOpen()){
            mWDB = mHelper.getWritableDatabase();
        }
        return mWDB;
    }

    // 关闭数据库连接
    public void closeLink(){
        if (mRDB != null && !mRDB.isOpen()){
            mRDB.close();
            mRDB = null;
        }

        if (mWDB != null && !mWDB.isOpen()){
            mWDB.close();
            mWDB = null;
        }
    }

    // 增删改函数设置
    // 1. insert() 的第一个参数就只是表名。
    // 2. 第二个参数将指示框架在 ContentValues 为空（即您没有 put 任何值）时应执行哪些操作。如果您指定列名称，框架会插入一行，并将该列的值设置为 null。如果您指定 null（如此代码示例所示），框架在没有值时不会插入行。
    // 3. insert() 方法会返回新创建行的 ID；如果在插入数据时出错，会返回 -1。如果您的数据与数据库中已有的数据之间存在冲突，就会出现这种情况。
    public long insert(User user){
        // ContentValue是键值对类型
        ContentValues values = new ContentValues();
        values.put("name", user.name);
        values.put("age",user.age);
        values.put("height",user.height);
        values.put("weight",user.weight);
        values.put("married",user.married);

        // 执行插入记录动作，该语句返回插入记录的行号
        // 如果第三个参数values位null或者元素个数为0，由于insert方法要求必须添加一条处理主键之外的其他字段为null的记录
        // 为了满足sql语法需求，insert语句必须给定这样一个字段，如：insert into person(name) values(NULL)
        // 倘若不给定字段名，insert语句就成为：insert into person() values(), 显然不满足标准SQL语法要求
        // 如果第三个参数values不为null且元素个数大于0，可以把第二个参数设置为null
        return mWDB.insert(TABLE_NAME, null, values);
    }

    public long deleteByName(String name){
        // 删除所有
        // mWDB.delete(TABLE_NAME, "1=1", null);
        return mWDB.delete(TABLE_NAME, "name=?", new String[] {name});
    }

    public long update(User user){
        ContentValues values = new ContentValues();
        values.put("name", user.name);
        values.put("age", user.age);
        values.put("height", user.height);
        values.put("weight", user.weight);
        values.put("married", user.married);
        return mWDB.update(TABLE_NAME, values, "name=?", new String[] {user.name});
    }

    // 查询
    public List<User> queryAll(){
        List<User> list = new ArrayList<>();
        // 执行记录查询动作，该语句返回结果集游标
        Cursor cursor = mRDB.query(TABLE_NAME, null, null, null, null, null,null);
        // 循环去除游标指向的记录
        while(cursor.moveToNext()){
            User user = new User();
            user.id = cursor.getInt(0);
            user.name = cursor.getString(1);
            user.age = cursor.getInt(2);
            user.height = cursor.getLong(3);
            user.weight = cursor.getFloat(4);
            user.married = (cursor.getInt(5) == 0) ? false : true;
            list.add(user);
        }

        return list;
    }

    public List<User> queryByName(String name){
        List<User> list = new ArrayList<>();
        // 执行记录查询动作，该语句返回结果集游标
        Cursor cursor = mRDB.query(TABLE_NAME, null, "name=?", new String[]{name}, null, null,null);
        // 循环去除游标指向的记录
        while(cursor.moveToNext()){
            User user = new User();
            user.id = cursor.getInt(0);
            user.name = cursor.getString(1);
            user.age = cursor.getInt(2);
            user.height = cursor.getLong(3);
            user.weight = cursor.getFloat(4);
            user.married = (cursor.getInt(5) == 0) ? false : true;
            list.add(user);
        }

        return list;
    }

    ```

2. 活动组件的activity代码
    - onCreate函数中指定id；
    - onStart函数中定义数据库帮助类，打开数据库读写连接；
    - onDestory函数中关闭数据库。
    ```java
    // 全局变量
    private UserDBHelper mHelper;
    @Override
    protected void onStart() {
        super.onStart();
        // 获得数据库帮助实例
        mHelper = UserDBHelper.getInstance(this);
        // 打开读写链接
        mHelper.openReadLink();
        mHelper.openWriteLink();
    }

    @Override
    protected void onStop() {
        super.onStop();
        //关闭数据库链接
        mHelper.closeLink();
    }

    ```


### 9.3 存储卡的文件操作

#### 9.3.1 java输入输出流
Java 输入输出流概述
输入输出流是 Java 中处理文件、网络连接和其他数据源的一种机制。主要有以下两种流：

字节流：用于处理原始二进制数据，如图片、视频等。主要类有 InputStream 和 OutputStream。
字符流：用于处理字符数据，适合处理文本文件。主要类有 Reader 和 Writer。
Java IO 中的类库分为传统的 java.io 包和较新的 java.nio 包（NIO，非阻塞IO），后者引入了通道（Channel）的概念。

1. BufferedWriter 类
    - BufferedWriter 是 Writer 类的子类，用于将文本写入字符输出流，提供了缓冲功能，能够减少写操作对磁盘的访问次数，从而提高性能。
        ```java
        // 使用 FileWriter 创建 BufferedWriter 对象时，可以指定要写入的文件路径。
        BufferedWriter bw = new BufferedWriter(new FileWriter("output.txt"));
        ```
    - 常用方法
        1. **write(String str)**：将字符串写入缓冲区。 
        ```java
        bw.write("Hello, World!");
        ```
        2. **newLine()**：写入一个行分隔符。不同操作系统的行分隔符可能不同。
        ```java
        bw.newLine();
        ```
        3. **flush()**：刷新缓冲区，将缓冲区的内容立即写入到目标文件。
        ```java
        bw.flush();
        ```
        4. **close()**：关闭流，释放相关资源。
        ```java
        bw.close();
        ```
    - 注意事项
        - **缓冲区大小**：`BufferedWriter` 默认使用一个内部缓冲区来提高性能。可以通过指定缓冲区大小来优化写入性能。
        - **关闭流**：确保在操作完成后关闭流，释放资源。可以使用 try-with-resources 语句来自动关闭流，如示例中的 `try (BufferedWriter bw = new BufferedWriter(new FileWriter(fileName))) { ... }`。
        - **异常处理**：处理可能抛出的 `IOException`，例如文件路径错误、磁盘空间不足等情况。


2. BufferedReader类
    - 在 Java 中，BufferedReader 属于字符流（Reader）的一种，它继承自 Reader 类，用于从输入字符流中读取文本，并且能够提供缓冲机制，减少了读取数据时对底层资源的频繁访问，从而提升了读取效率。
    - 构造方法
        ```java
        // BufferedReader 通过 FileReader 对象构造，用于读取指定文件 "file.txt" 的字符数据。
        BufferedReader reader = new BufferedReader(new FileReader("file.txt"));
        ```
    - 常用方法
        1. **read() 方法**
            ```java
            // 从输入流中读取一个字符的 Unicode 值，如果已到达流的末尾，则返回 -1
            int charValue = reader.read();
            ```
        2. **readLine() 方法**
            ```java
            // 从输入流中读取一行文本数据，并返回一个字符串。当读取到行尾或者文件末尾时返回 null。
            String line = reader.readLine();
            ```
        3. **close() 方法**
            ```java
            // 关闭输入流，释放资源。在读取完成后应该调用 `close()` 方法来确保资源的正常释放。
            reader.close();
            ```
        4. **reset() 和 mark() 方法**
            - `reset()`：将流的当前位置重置到之前调用 `mark()` 方法时的位置，用于重新读取流中的数据。
            - `mark(int readAheadLimit)`：在当前位置设定一个标记，以后可以通过 `reset()` 方法返回到这个位置。

    - 注意事项
        - **缓冲机制**：`BufferedReader` 使用内部缓冲区来存储从底层输入流中读取的数据，通过减少实际的 I/O 操作次数来提高性能。
        - **字符编码**：在构造 `FileReader` 时未指定字符编码时，默认使用平台默认的字符编码。
        - **资源释放**：在使用完 `BufferedReader` 后，应该及时调用 `close()` 方法释放资源，避免资源泄露。
        - **适用场景**：适用于读取文本文件内容，处理文本数据的场景，如配置文件读取、日志文件处理等。



3. try-catch-final机制
    try-catch-finally 结构是 Java 中用于异常处理和资源管理的重要语法块。它允许程序员在可能抛出异常的代码块中捕获异常，并在异常发生时执行特定的处理代码，同时确保无论是否发生异常都能执行某些必要的清理操作。

    ```java
    try {
        // 可能会抛出异常的代码块
        // 在这里进行文件操作、网络请求或其他可能引发异常的操作
    } catch (ExceptionType e) {
        // 异常处理代码块
        // 当 try 块中抛出 ExceptionType 类型的异常时，这里会捕获并处理异常
    } finally {
        // finally 块
        // 无论是否抛出异常，这里的代码块都会被执行
        // 通常用于释放资源或执行清理操作，例如关闭文件流或数据库连接
    }
    ```

#### 9.3.2 外部文件存储
安卓存储空间分为三种主要类型：内部存储空间、外部私有存储空间和外部公共存储空间。

简单总结为：
| 存储空间类型            | 特点                                                         | 路径获取方法                             | 主要用途                                                     |
|-------------------------|--------------------------------------------------------------|-------------------------------------------|--------------------------------------------------------------|
| 内部存储空间 (Internal Storage) | 应用私有，其他应用无法访问；数据在应用卸载时被删除。         | `Context.getFilesDir()`                   | 存储应用的私有数据，如用户首选项、数据库、缓存文件等。        |
| 外部私有存储空间 (External Private Storage) | 应用私有，其他应用无法直接访问；允许存储在外部存储介质上。 | `Context.getExternalFilesDir(Environment.DIRECTORY_TYPE)` | 存储对用户有用的大量数据，如下载的文件、媒体内容等。          |
| 外部公共存储空间 (External Public Storage) | 用户和其他应用可访问；需要特定权限。                         | `Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_TYPE)` | 存储需要与其他应用共享的数据，如图片、音频、视频等。          |



1. **路径获取方法**：
   - `Context.getFilesDir()`：获取内部存储空间的根目录。
   - `Context.getExternalFilesDir(Environment.DIRECTORY_TYPE)`：获取外部私有存储空间的根目录，`DIRECTORY_TYPE` 可以是 `DIRECTORY_DOWNLOADS`、`DIRECTORY_PICTURES` 等。
   - `Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_TYPE)`：获取外部公共存储空间的根目录，`DIRECTORY_TYPE` 可以是 `DIRECTORY_DOWNLOADS`、`DIRECTORY_DCIM` 等。

2. **主要用途**：
   - **内部存储空间**适合存储应用的私有数据，确保数据的安全性和隐私性。
   - **外部私有存储空间**适合存储大文件和用户可管理的数据，不同应用之间的数据是隔离的。
   - **外部公共存储空间**适合存储需要与其他应用共享的数据，需要注意权限控制以保护数据安全性。
        - 同时需要在清单文件加上权限
            ```xml
            <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
            <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
            // 新加属性
            android:requestLegacyExternalStorage="true"
            ```

3. **注意事项**：
   - 在使用外部存储空间时，特别是外部公共存储空间，应用需要请求适当的权限（如读写外部存储权限）。
   - 内部存储空间的数据在应用卸载时会被删除，外部存储空间的数据则会保留，直到用户手动删除或卸载相关应用。

外部私有存储文件存储位置：
![alt text](img/image-12.png)

外部公共存储文件存储位置：
![alt text](img/image-13.png)

具体代码：
```java
// System.currentTimeMillis() 返回当前时间的毫秒数，用作文件名，确保文件名唯一性。
// getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS) 是 Android 提供的方法，用于获取应用的外部文件目录，指定了文件存储的目录为 Downloads。
String fileName = System.currentTimeMillis() + ".txt";
String directory = null;
// 外部存储私有空间
directory = getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS).toString();
// 外部存储公共空间
directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).toString();
// 内部存储空间,data目录下面
directory = getFilesDir().toString();

path = directory + File.separatorChar + fileName;
// 日志输出
Log.d("ning", path);
FileUtil.saveText(path, sb.toString());
```


### 9.4 应用组件Application

参考教程：
[应用组件Application](https://blog.csdn.net/qq_45649553/article/details/136543933)


### 9.5 Room学习
Jetpack Room 是 Android Jetpack 提供的一个数据库处理框架，旨在简化 SQLite 数据库的使用。它通过注解技术简化数据库的操作，减少编码工作量。

在使用Room之前，需要先修改模块的build.gradle文件，向dependencies节点添加配置：
```json
implementation("androidx.room:room-runtime:2.2.5")
annotationProcessor("androidx.room:room-compiler:2.2.5")
```

每次使用数据库帮助器都需要手工实现以下逻辑：
1. 重写onCreate方法，添加建表语句；
2. 插入记录时，必须奖数据实例的属性逐一赋值给该表的各字段；
3. 在查询记录时，必须先遍历结果游标集，吧各个字段逐一赋值给数据实例；
4. 每次读写操作之前，都需要开启数据库连接，读写完成之后关闭连接。

使用Room框架的编码步骤：
1. 实体类添加`@Entity`注解；
2. 持久化类添加`@Dao`注解；
3. 编写数据库类，应从`RoomDataBase`派生来，并添加`@DataBase`注解；
4. 在自定义的`Application`类中声明数据库类的唯一实例；
5. 获取持久化对象。


具体代码讲解：
1. 实体类：
```java
// 注解，实体类
@Entity
public class BookInfo {
    // 注解主键
    @PrimaryKey(autoGenerate = true)
    private int id;
    // 其他键名...

    // 统一设置成private属性，然后用生成器创建每个变量的接口..
}

```

2. 持久化类Dao(一个接口)
@Query注解可以设置数据库操作语句
```java
package com.example.week3test.dao;

@Dao
public interface BookDao {

    // 形参数量可变
    @Insert
    void insert(BookInfo... book);
    @Delete
    void delete(BookInfo... book);
    @Query("DELETE FROM BookInfo")
    void deleteAll();

    @Update
    int update(BookInfo... book);
    @Query("SELECT * FROM BookInfo")
    List<BookInfo> queryAll();
    @Query("SELECT * FROM BookInfo WHERE name=:name ORDER BY id DESC limit 1")
    BookInfo queryByName(String name);
}

```

3. 编写数据库类，应从`RoomDataBase`派生来
```java
package com.example.week3test.database;

// entities 表示该数据库多少表格，version表示数据库版本号
// exportSchema表示是否到处数据库信息json，建议为false，true好需要指定json，这是为了方便调试
@Database(entities = {BookInfo.class}, version = 1, exportSchema = false)
public abstract class BookDatebase extends RoomDatabase {
    // 获取持久化数据
    public abstract BookDao bookDao();

}

 // 可以再activity中获取数据库
bookDao = MyApplication.getInstance().getBookDB().bookDao();
```

总结以下：
1. 用room操作数据库需要三个部分，实体类、持久化类Dao和数据库类；
2. 持久化类是一个接口，主要使用Room里面的注解来简化数据库的操作，包括增删查改等等；
3. 数据库类是一个抽象类，需要继承RoomDatabase类，并且使用注解，简化创建表格的操作。

持久化类dao和数据库类（抽象类）的关系，数据库类用一个抽象方法返回了一个持久化类（dao）的接口。
- BookDao 接口定义操作：BookDao 接口定义了对数据库进行操作的方法，使用 Room 的注解来标识这些方法是用于插入、删除、更新和查询的。
- BookDatabase 类提供 BookDao 实例：BookDatabase 类通过 bookDao() 方法提供 BookDao 的实例。这个实例由 Room 自动生成，包含了 BookDao 接口中定义的所有方法的实现。


接口本身不能直接实例化，因为接口只是定义了一组方法，而没有具体的实现。但在使用 Room 框架时，Room 会在编译时自动生成实现这些接口的方法，从而间接实现了接口的实例化。


### 9.6 购物车案例

#### 9.6.1 图像存储带外部存储空间

| 类名              | 主要功能                              | 创建实例                               | 主要方法                                      | 典型用途                                       |
|-------------------|---------------------------------------|----------------------------------------|----------------------------------------------|------------------------------------------------|
| `Bitmap`          | 表示和操作位图图像                    | - 从资源文件：`BitmapFactory.decodeResource`<br>- 从文件路径：`BitmapFactory.decodeFile`<br>- 手动创建：`Bitmap.createBitmap` | - `compress`：压缩并保存图像<br>- `createScaledBitmap`：缩放图像<br>- `createBitmap`：创建新位图 | 表示和操作位图图像，如绘图、缩放、旋转等          |
| `FileOutputStream`| 将数据写入文件                        | - 文件路径：`new FileOutputStream(path)`<br>- 文件对象：`new FileOutputStream(file)` | - `write`：写入字节数据<br>- `close`：关闭输出流 | 将数据保存到文件中，如保存 `Bitmap` 为图像文件   |
| `FileInputStream` | 从文件中读取数据                      | - 文件路径：`new FileInputStream(path)`<br>- 文件对象：`new FileInputStream(file)` | - `read`：读取字节数据<br>- `close`：关闭输入流 | 从文件中读取数据，如从文件中加载 `Bitmap` 图像  |

1. `Bitmap` 示例代码

```java
// 从资源文件中创建 Bitmap
Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.image);

// 从文件路径中读取 Bitmap
Bitmap bitmap = BitmapFactory.decodeFile(filePath);

// 手动创建一个空白的 Bitmap
Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);

// 压缩并保存 Bitmap
FileOutputStream fos = new FileOutputStream("path/to/image.jpg");
bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos);
fos.close();
```

2. `FileOutputStream` 示例代码

```java
FileOutputStream fos = null;
try {
    // 通过文件路径创建 FileOutputStream
    fos = new FileOutputStream("path/to/file.txt");
    String data = "Hello, World!";
    fos.write(data.getBytes());  // 写入字符串数据
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (fos != null) {
        try {
            fos.close();  // 关闭输出流
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

// 保存 Bitmap 到文件
FileOutputStream fos = new FileOutputStream("path/to/image.jpg");
bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos);
fos.close();
```

3. `FileInputStream` 示例代码

```java
FileInputStream fis = null;
try {
    // 通过文件路径创建 FileInputStream
    fis = new FileInputStream("path/to/file.txt");
    int content;
    while ((content = fis.read()) != -1) {
        // 处理读取的数据
        System.out.print((char) content);
    }
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (fis != null) {
        try {
            fis.close();  // 关闭输入流
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

// 从文件中加载 Bitmap
FileInputStream fis = new FileInputStream("path/to/image.jpg");
Bitmap bitmap = BitmapFactory.decodeStream(fis);
fis.close();
```


#### 9.6.2 数据库创建
1. 准备号购物车实体类和商品实体类；
2. 写好购物车案例的数据库帮助类`ShoppingDBHelper`,继承自`SQLiteOpenHelper`;
    - 在数据库中建表——cart和Goods；
    - 增删改查；
    - 注意这里使用单例模式，保证全局性和数据一致性。
3. 在`myApplication`组件中初始化商品信息数据；
    - 打开购物车帮助类，创建数据库；
    - 向网络发出请求，奖商品数据加载到数据库中；
    - 关闭数据库；
    - 此时形成了一个唯一单例，其他组件都可以同步数据库信息.

关键代码:
1. MyApplication类中初始化商品信息
```java
private void initGoodsInfo() {
    // 获取共享参数保存的是否首次打开参数
    boolean isFirst = SharedUtil.getInstance(this).readBoolean("first", true);
    // 获取当前app的私有下载路径
    String directory = getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS).toString() + File.separatorChar;
    // 模拟网络请求图片下载
    if(isFirst){
        // 下载
        List<GoodsInfo> list = GoodsInfo.getDefaultList();
        for (GoodsInfo info: list) {
            Bitmap bitmap = BitmapFactory.decodeResource(getResources(), info.pic);
            String path = directory+info.id+".jpg";
            // 外存中存储图片
            FileUtil.saveImage(path, bitmap);
            // 回收位图图像
            bitmap.recycle();
            info.picPath = path;
        }

        // 打开数据库
        ShoppingDBHelper dbHelper = ShoppingDBHelper.getInstance(this);
        dbHelper.openWriteLink();
        dbHelper.insertGoodsInfos(list);
        dbHelper.closeLink();
        //把是否是首次打开写入共享参数
        SharedUtil.getInstance(this).writeBoolean("first", false);
    }

}
```

2. shoppingDBHelper帮助类建表
```java
package com.example.week3test.database;
public class ShoppingDBHelper extends SQLiteOpenHelper {

    // ... 数据库信息
    private static ShoppingDBHelper mHelper = null;         // 单例模式
    // 数据库的读写需要基于锁来保证安全性，所以先创建两个实例
    private SQLiteDatabase mRDB = null;
    private SQLiteDatabase mWDB = null;

    public ShoppingDBHelper(Context context) {
        super(context, DB_NAME, null, DB_VERSION);
    }
    // 利用单例模式获取数据库帮助器的唯一实例
    // 以后请补充上同步快处理，加锁，考虑并发问题
    public static ShoppingDBHelper getInstance(Context context){
        if (mHelper == null){
            mHelper =new ShoppingDBHelper(context);
        }
        return mHelper;
    }

    // 创建数据库，执行建表语句
    @Override
    public void onCreate(SQLiteDatabase db) {
        String sql = "CREATE TABLE IF NOT EXISTS " + TABLE_GOODS_NAME + " (" +
                "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL," +
                " name VARCHAR NOT NULL," +
                " description VARCHAR NOT NULL," +
                " price FLOAT NOT NULL," +
                " pic_path VARCHAR NOT NULL);";
        db.execSQL(sql);

        // 购物车信息表
        sql = "CREATE TABLE IF NOT EXISTS " + TABLE_CART_NAME + " (" +
                "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL," +
                " goods_id INTEGER NOT NULL," +
                " count INTEGER NOT NULL);";
        db.execSQL(sql);
    }

    // 插入商品信息
    public void insertGoodsInfos(List<GoodsInfo> list){
        // 插入多条记录
        try{
            mWDB.beginTransaction();
            for (GoodsInfo info:list) {
                ContentValues values = new ContentValues();
                values.put("name", info.name);
                values.put("description", info.description);
                values.put("price", info.price);
                values.put("pic_path", info.picPath);
                mWDB.insert(TABLE_GOODS_NAME, null, values);
            }
            mWDB.setTransactionSuccessful();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            mWDB.endTransaction();
        }
    }

}

```


#### 9.6.3 布局
1. 顶部标题导航栏
    - 相对布局设置
```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="50dp"
    android:background="#aaaaff">

    <ImageView
        android:id="@+id/iv_back"
        android:layout_width="50dp"
        android:layout_height="match_parent"
        android:layout_alignParentLeft="true"
        android:padding="10dp"
        android:scaleType="fitCenter"
        android:src="@drawable/ic_back"/>

    <TextView
        android:id="@+id/tv_shopping_title"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:layout_centerInParent="true"
        android:gravity="center"
        android:textColor="@color/black"
        android:textSize="20sp"/>

    <ImageView
        android:id="@+id/iv_cart"
        android:layout_width="50dp"
        android:layout_height="match_parent"
        android:layout_alignParentRight="true"
        android:scaleType="fitCenter"
        android:src="@drawable/cart"/>

    <TextView
        android:id="@+id/tv_count"
        android:layout_width="20dp"
        android:layout_height="20dp"
        android:layout_alignParentTop="true"
        android:layout_toRightOf="@+id/iv_cart"
        android:layout_marginLeft="-20dp"
        android:gravity="center"
        android:textColor="@color/white"
        android:text="0"
        android:textSize="15sp"
        android:background="@drawable/shape_oval_red"/>

</RelativeLayout>
```


2. 商品界面
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/orange"
    android:orientation="vertical">

    <include layout="@layout/title_shopping"/>
    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <GridLayout
            android:id="@+id/gl_channel"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:columnCount="2"/>

    </ScrollView>

</LinearLayout>
```

3. 具体商品条目item
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/ll_item"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_gravity="center"
    android:background="@color/white"
    android:gravity="center"
    android:orientation="vertical">

    <TextView
        android:id="@+id/tv_name"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center"
        android:textColor="@color/black"
        android:textSize="17sp"
        android:text="小米手机"/>

    <ImageView
        android:id="@+id/iv_thumb"
        android:layout_width="180dp"
        android:layout_height="150dp"
        android:scaleType="fitCenter"
        tools:src="@drawable/xiaomi"/>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="45dp"
        android:orientation="horizontal">

        <TextView
            android:id="@+id/tv_price"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="2"
            android:gravity="center"
            android:textColor="@color/red"
            android:textSize="15sp"
            android:text="20"/>

        <Button
            android:id="@+id/btn_add"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="3"
            android:gravity="center"
            android:text="加入购物车"
            android:textColor="@color/black"
            android:textSize="15sp"
            tools:ignore="TouchTargetSizeCheck" />

    </LinearLayout>
</LinearLayout>
```


#### 9.6.4 在主界面动态更新商品信息
在该界面的生命周期中加载出来商品信息,除了需要创建好数据库并且向网络请求数据之外,还需要奖数据加载到页面上.

逻辑是:
1. 数据库查询出所有商品信息;
2. 在java代码中构建一个商品条目对象,循环将每一个商品信息传递给改对象,并且插入到布局文件节点中:

主要代码:
1. 数据库查询
```java
public List<GoodsInfo> queryAllGoodsInfo(){

        String sql = "select * from " + TABLE_GOODS_NAME;
        List<GoodsInfo> list = new ArrayList<>();
        Cursor cursor = mRDB.rawQuery(sql, null);
        while (cursor.moveToNext()){
            GoodsInfo info = new GoodsInfo();
            info.id = cursor.getInt(0);
            info.name = cursor.getString(1);
            info.description = cursor.getString(2);
            info.price = cursor.getFloat(3);
            info.picPath = cursor.getString(4);
            list.add(info);
        }
        cursor.close();
        return list;
    }
```

2. 构建一个商品条目对象
    - 获取屏幕宽度
        - `int screenWidth = getResources().getDisplayMetrics().widthPixels;`
            - getResources()：这是一个上下文方法，用于获取应用程序资源。
            - getDisplayMetrics()：获取屏幕显示指标，包括屏幕的宽度、高度、密度等。
            - widthPixels：屏幕宽度的像素值。
    - 设置布局参数
        - `LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(screenWidth / 2, LinearLayout.LayoutParams.WRAP_CONTENT);`
            - LinearLayout.LayoutParams：这是 LinearLayout 的布局参数类，用于控制子视图在 LinearLayout 中的位置和大小。
            - screenWidth / 2：将屏幕宽度的一半作为每个商品条目的宽度。
            - LinearLayout.LayoutParams.WRAP_CONTENT：高度设置为包裹内容，即根据内容的高度来动态调整。
```java
// 商品条目是一个线性布局，设置布局的宽度为屏幕的一般
int screenWidth = getResources().getDisplayMetrics().widthPixels;
LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(screenWidth / 2, LinearLayout.LayoutParams.WRAP_CONTENT);
```

3. 添加到网格布局中
```java
for (GoodsInfo info: list) {
    // 获取布局item_goods.xml的根视图
    // 变成一个java对象
    View view = LayoutInflater.from(this).inflate(R.layout.item_goods, null);
    ImageView iv_thumb = view.findViewById(R.id.iv_thumb);
    TextView tv_name = view.findViewById(R.id.tv_name);
    TextView tv_price = view.findViewById(R.id.tv_price);
    // 动态设置值
    iv_thumb.setImageURI(Uri.parse(info.picPath));
    tv_name.setText(info.name);
    // Log.d("price", String.valueOf(info.price));
    tv_price.setText(String.valueOf((int) info.price));

    // 把商品视图添加到网格布局
    gl_channel.addView(view, params);

}
```



#### 9.6.5 加入购物车
点击添加按钮,更新在MyApplication中的购物车的全局变量和CartInfo数据库.值得注意的是当从其他页面切换到商品页面时,需要在`onResume`生命周期中查询数据库,更新全局变量cartCount.

1. 数据库帮助类的函数,包括添加到购物车表,根据商品信息查询购物车表,计算购物车中商品总数.
```java
 public void insertCartInfo(int goodsId) {
    // 不存在商品就添加
    CartInfo cartInfo = queryCartInfoByGoodsId(goodsId);
    ContentValues values = new ContentValues();
    values.put("goods_id", goodsId);
    if (cartInfo == null){
        values.put("count",1);
        mWDB.insert(TABLE_CART_NAME, null, values);
    }else{
        values.put("_id", cartInfo.id);
        values.put("count", ++cartInfo.count);
        mWDB.update(TABLE_CART_NAME, values, "_id=?", new String[]{String.valueOf(cartInfo.id)});
    }
    //有就增加数量

}

private CartInfo queryCartInfoByGoodsId(int goodsId) {
    Cursor cursor = mRDB.query(TABLE_CART_NAME, null, "goods_id=?", new String[]{String.valueOf(goodsId)}, null, null,null);
    CartInfo info = null;
    if (cursor.moveToNext()){
        info = new CartInfo();
        info.id = cursor.getInt(0);
        info.goodsId = cursor.getInt(1);
        info.count = cursor.getInt(2);
        Log.d("ning", String.valueOf(info.goodsId));
    }
    return info;
}

public int countCartInfo() {
    int count = 0;
    String sql = "select sum(count) from " + TABLE_CART_NAME;
    Cursor cursor = mRDB.rawQuery(sql, null);
    if (cursor.moveToNext()){
        count = cursor.getInt(0);
    }
    return count;
}

```


2. 商品信息界面
```java
// 按钮事件监听
Button btn_add = view.findViewById(R.id.btn_add);
btn_add.setOnClickListener(v -> {
    addToCart(info.id, info.name);
});

private void addToCart(int goodsId, String name) {
    mDBHelper.insertCartInfo(goodsId);
    // 购物车数量+1
    int cnt = ++MyApplication.getInstance().goodsCount;
    tv_count.setText(String.valueOf(cnt));
    ToastUtil.show(this,"已添加到购物车");
}

// onResume是当从其他页面跳转到该页面之后，需要执行的操作
@Override
protected void onResume() {
    super.onResume();
    // 查询购物车商品总数
    // 可能在其他页面删除或者增加了商品总数
    showCartInfoTotal();
}

private void showCartInfoTotal() {
    int count = mDBHelper.countCartInfo();
    MyApplication.getInstance().goodsCount = count;
    tv_count.setText(String.valueOf(count));
}
```


#### 9.6.6 购物车列表展示
这里有几个工作,首先设置购物车单个表格的视图,这样可以根据数据库数据动态更新视图;其次是需要计算和更新总体金额.

1. 单个购物车表项视图
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    xmlns:tools="http://schemas.android.com/tools"
    android:background="@color/white"
    android:orientation="horizontal">

    <ImageView
        android:id="@+id/iv_thumb"
        android:layout_width="85dp"
        android:layout_height="85dp"
        android:scaleType="fitCenter"
        tools:src="@drawable/xiaomi"/>

    <LinearLayout
        android:layout_marginLeft="5dp"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="3"
        android:orientation="vertical">

        <TextView
            android:id="@+id/tv_name"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="2"
            android:gravity="left|center"
            android:textColor="@color/black"
            android:textSize="17sp"
            tools:text="小米手机"/>

        <TextView
            android:id="@+id/tv_desc"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="3"
            android:gravity="center|left"
            android:textColor="@color/black"
            android:textSize="12sp"
            tools:text="小米 MInt0 8GB+128GB 塞克的环境模板名称"/>

    </LinearLayout>

    <TextView
        android:id="@+id/tv_count"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1"
        android:gravity="center"
        android:textColor="@color/black"
        android:textSize="17sp"
        tools:text="2"/>

    <TextView
        android:id="@+id/tv_price"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1"
        android:gravity="center"
        android:textColor="@color/black"
        android:textSize="17sp"
        tools:text="1000"/>

    <TextView
        android:id="@+id/tv_sum"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1"
        android:gravity="center"
        android:textColor="@color/black"
        android:textSize="17sp"
        tools:text="2000"/>

</LinearLayout>
```


2. 购物车界面
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:tools="http://schemas.android.com/tools"
    android:orientation="vertical"
    android:background="@color/orange"
    >

    <include layout="@layout/title_shopping"/>

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <RelativeLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <LinearLayout
                android:id="@+id/ll_content"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:visibility="visible">

                <!--                    表头-->
                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal">

                    <TextView
                        android:layout_width="85dp"
                        android:layout_height="wrap_content"
                        android:gravity="center"
                        android:text="图片"
                        android:textColor="@color/black"
                        android:textSize="15sp"/>

                    <TextView
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="3"
                        android:gravity="center"
                        android:text="名称"
                        android:textColor="@color/black"
                        android:textSize="15sp"/>

                    <TextView
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:gravity="center"
                        android:text="数量"
                        android:textColor="@color/black"
                        android:textSize="15sp"/>

                    <TextView
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:gravity="center"
                        android:text="单价"
                        android:textColor="@color/black"
                        android:textSize="15sp"/>

                    <TextView
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:gravity="center"
                        android:text="总价"
                        android:textColor="@color/black"
                        android:textSize="15sp"/>

                </LinearLayout>
                <!--                    购物车-->
                <LinearLayout
                    android:id="@+id/ll_cart"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"/>
                <!--总结-->
                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="horizontal"
                    android:padding="0dp">

                    <Button
                        android:id="@+id/btn_clear"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:gravity="center"
                        android:text="清空"
                        android:textColor="@color/black"
                        android:textSize="17sp"/>

                    <TextView
                        android:layout_width="0dp"
                        android:layout_height="wrap_content"
                        android:layout_weight="1"
                        android:gravity="center|right"
                        android:text="总金额:  "
                        android:textColor="@color/black"
                        android:textSize="17sp"/>

                    <TextView
                        android:id="@+id/tv_total_price"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginRight="10dp"
                        android:gravity="center|left"
                        android:textColor="@color/red"
                        android:text="0"
                        android:textSize="25sp"/>

                    <Button
                        android:id="@+id/btn_settle"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:gravity="center"
                        android:text="结算"
                        android:textColor="@color/black"
                        android:textSize="17sp"/>

                </LinearLayout>

            </LinearLayout>

            <LinearLayout
                android:id="@+id/ll_empty"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                android:visibility="gone"
                tools:visibility="visible">

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="100dp"
                    android:layout_marginBottom="100dp"
                    android:gravity="center"
                    android:text="哎呀，购物车空空如也，快去选购商品吧~"
                    android:textColor="@color/black"
                    android:textSize="17sp"/>

                <Button
                    android:id="@+id/btn_shopping_channel"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:gravity="center"
                    android:text="逛逛手机商城"
                    android:textColor="@color/black"
                    android:textSize="17sp"/>

            </LinearLayout>

        </RelativeLayout>


    </ScrollView>

</LinearLayout>
```

3. 购物车界面逻辑
    - 更新视图列表;
    - 计算总价;
    ```java
    package com.example.week3test;

    public class ShoppingCartActivity extends AppCompatActivity implements View.OnClickListener {

        private TextView tv_count, tv_total_price;
        private ShoppingDBHelper mDBHelper;
        // 购物车列表布局
        private LinearLayout ll_cart;
        // 购物车信息列表
        private List<CartInfo> mCartList;
        // 声明一个根据商品编号查找商品信息的map映射，吧商品信息缓存起来，这样就不用每一次去查询数据库
        private HashMap<Integer, GoodsInfo> mGoodsMap = new HashMap<>();


        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_shopping_cart);

            TextView tv_title = findViewById(R.id.tv_shopping_title);
            tv_title.setText("购物车");

            // 购物车中商品数量
            tv_count = findViewById(R.id.tv_count);
            tv_count.setText(String.valueOf(MyApplication.getInstance().goodsCount));
            tv_total_price = findViewById(R.id.tv_total_price);

            // 获得购物车列表
            ll_cart = findViewById(R.id.ll_cart);

            // 创建数据库帮助类
            mDBHelper = ShoppingDBHelper.getInstance(this);

            // 返回
            findViewById(R.id.iv_back).setOnClickListener(this);

        }

        @Override
        protected void onResume() {
            super.onResume();
            showCart();
        }

        // 展示购物车的商品列表
        private void showCart() {
            // 移除所有子视图
            ll_cart.removeAllViews();
            // 查询购物车数据库的所有商品记录
            mCartList = mDBHelper.queryAllCartInfo();
            if (mCartList.size() == 0){
                return;
            }

            for (CartInfo info: mCartList) {
                // 根据商品编号查询商品数据库的商品记录
                GoodsInfo goods = mDBHelper.queryGoodsById(info.goodsId);
                mGoodsMap.put(info.goodsId,goods);

                // 获取布局文件item_cart.xml根视图
                View view = LayoutInflater.from(this).inflate(R.layout.item_cart,null);
                ImageView iv_thumb = view.findViewById(R.id.iv_thumb);
                TextView tv_name = view.findViewById(R.id.tv_name);
                TextView tv_count = view.findViewById(R.id.tv_count);
                TextView tv_price = view.findViewById(R.id.tv_price);
                TextView tv_sum = view.findViewById(R.id.tv_sum);
                TextView tv_desc = view.findViewById(R.id.tv_desc);

                iv_thumb.setImageURI(Uri.parse(goods.picPath));
                tv_name.setText(goods.name);
                tv_desc.setText(goods.description);
                tv_count.setText(String.valueOf(info.count));
                tv_price.setText(String.valueOf((int) goods.price));
                tv_sum.setText(String.valueOf((int) (goods.price * info.count)));

                // 向购物车列表添加
                ll_cart.addView(view);
            };

            // 计算总金额
            refreshTotalPrice();

        }

        private void refreshTotalPrice() {
            int totalPrice = 0;
            for(CartInfo info: mCartList){
                GoodsInfo goods = mGoodsMap.get(info.goodsId);
                totalPrice += goods.price * info.count;
            }

            tv_total_price.setText(String.valueOf(totalPrice));


        }


        @Override
        public void onClick(View v) {
            if (v.getId() == R.id.iv_back){
                finish();
            }
        }
    }
    ```


#### 9.6.7 清空购物车
1. 根据购物车商品个数来展示列表

```java
// 展示函数
private void showCount() {
    tv_count.setText(String.valueOf(MyApplication.getInstance().goodsCount));
    // 购物车没有商品
    if (MyApplication.getInstance().goodsCount == 0){
        ll_empty.setVisibility(View.VISIBLE);
        // 表头隐藏
        ll_content.setVisibility(View.GONE);
        // 购物车全部清楚
        ll_cart.removeAllViews();
    } else {
        ll_empty.setVisibility(View.GONE);
        // 表头隐藏
        ll_content.setVisibility(View.VISIBLE);
    }
}

// 按钮点击事件
if (v.getId() == R.id.btn_clear) {
    // 在数据库中删除
    mDBHelper.deleteAllCartInfo();
    MyApplication.getInstance().goodsCount = 0;
    showCount();
    ToastUtil.show(this,"已经全部删除");
}else if (v.getId() == R.id.btn_settle) {
    AlertDialog.Builder builder = new AlertDialog.Builder(ShoppingCartActivity.this);
    builder.setTitle("结算商品");
    builder.setMessage("抱歉，尚未开通支付功能");
    builder.setPositiveButton("我知道了",null);
    builder.create().show();
}

```


## 10. 高级控件
### 10.1 下拉列表

参考教程:
1. [下拉列表Spinner](https://blog.csdn.net/Mq_sir/article/details/117928511)
2. [适配器列表总结](https://blog.csdn.net/Tir_zhang/article/details/127152594)

数组适配器ArrayAdapter
1. 最简单的适配器,只展示一行文字;
2. 步骤:
    - 编写列表项的xml;
    - 调用ArrayAdapter构造方法,填入需要展示的字符串以及列表项的xml文件;
    - 调用下拉框控件的`setAdapter`方法,传入适配器实例.
```java
// 全局变量
private final static String[] starArray = {
        "水星",
        "木星",
        "火星",
        "地球",
        "金星"
};
private Spinner sp_downdrop,sp_dialog;

// 生命周期函数中的初始化
// 1. 找到组件
// 2. 声明适配器 3. 设置适配器  4. 设置默认选中  5. 设置选择监听事件
sp_downdrop = findViewById(R.id.sp_dropdown);
sp_dialog = findViewById(R.id.sp_dialog);
// 声明一个数组适配器
ArrayAdapter<String> startAdapter = new ArrayAdapter<>(this, R.layout.item_selector, starArray);
sp_downdrop.setAdapter(startAdapter);

sp_dialog.setPrompt("请选择星球");
sp_dialog.setAdapter(startAdapter);
// 默认选中第一项
sp_downdrop.setSelection(0);
sp_dialog.setSelection(0);
// 给下拉框设置选中监听器
sp_downdrop.setOnItemSelectedListener(this);
sp_dialog.setOnItemSelectedListener(this);

```



简单适配器SimpleAdapter
1. 允许在列表项同时展示文本和图片
2. 需要一个关于map映射list列表,存放每一个列表项的映射关系
    - ![alt text](img/image-14.png)
```java
// 声明一个映射对象列表，用于保存图标和名称的配对信息
List<Map<String, Object>> list = new ArrayList<>();
// 遍历存放
for (int i = 0; i < iconArray.length; i++) {
    Map<String, Object> item = new HashMap<>();
    item.put("icon", iconArray[i]);
    item.put("name", starArray[i]);
    list.add(item);
}
// 创建适配器
SimpleAdapter simpleAdapter = new SimpleAdapter(this,list,
        R.layout.item_simple,
        new String[]{"icon", "name"},
        new int[]{R.id.iv_icon, R.id.tv_name});
// 找到下拉列表
sp_simple = findViewById(R.id.sp_icon);
sp_simple.setAdapter(simpleAdapter);
sp_simple.setSelection(0);
sp_simple.setOnItemSelectedListener(this);
```



基础适配器BaseAdapter
1. 功能相对复杂
2. 是一个抽象接口,需要用类去实现.
    - 适配器类
    ```java
    package com.example.week3test.adapter;
    public class PlanetBaseAdapter extends BaseAdapter {

        // 上下文
        private Context mContext;
        // 映射信息列表
        private List<Planet> mPlanetList;

        public PlanetBaseAdapter(Context mContext, List<Planet> mPlanetList) {
            this.mContext = mContext;
            this.mPlanetList = mPlanetList;
        }

        // 集合的元素——列表项的个数
        @Override
        public int getCount() {
            return mPlanetList.size();
        }

        // 返回列表项
        @Override
        public Object getItem(int position) {
            return mPlanetList.get(position);
        }

        @Override
        public long getItemId(int position) {
            return position;
        }

        // 设置列表项布局数据
        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            // 根据布局我呢见生成转换成试图数据
            View view = LayoutInflater.from(mContext).inflate(R.layout.item_base, null);
            ImageView iv_icon = view.findViewById(R.id.iv_icon);
            TextView tv_name = view.findViewById(R.id.tv_name);
            TextView tv_desc = view.findViewById(R.id.tv_desc);

            // 给控制设置好数据
            Planet planet = mPlanetList.get(position);
            iv_icon.setImageResource(planet.image);
            tv_name.setText(planet.name);
            tv_desc.setText(planet.desc);

            return view;
        }
    }

    ```
    - activity设置代码
    ```java
    // 基本适配器使用
    sp_base = findViewById(R.id.sp_base);
    // 获取默认列表
    planetList = Planet.getDefaultList();
    // 构建一个列表适配器
    PlanetBaseAdapter planetBaseAdapter = new PlanetBaseAdapter(this, planetList);
    sp_base.setAdapter(planetBaseAdapter);
    sp_base.setSelection(0);
    sp_base.setOnItemSelectedListener(this);
    ```


convertView复用:
1. getView 方法中的 convertView 参数是为了优化性能，通过重用旧的视图对象来减少视图的创建次数
2. 改进代码:
```java
@Override
public View getView(int position, View convertView, ViewGroup parent) {
    ViewHolder holder;

    if (convertView == null) {
        convertView = LayoutInflater.from(mContext).inflate(R.layout.item_base, parent, false);
        holder = new ViewHolder();
        holder.iv_icon = convertView.findViewById(R.id.iv_icon);
        holder.tv_name = convertView.findViewById(R.id.tv_name);
        holder.tv_desc = convertView.findViewById(R.id.tv_desc);
        convertView.setTag(holder);
    } else {
        holder = (ViewHolder) convertView.getTag();
    }

    Planet planet = mPlanetList.get(position);
    holder.iv_icon.setImageResource(planet.image);
    holder.tv_name.setText(planet.name);
    holder.tv_desc.setText(planet.desc);

    return convertView;
}

static class ViewHolder {
    ImageView iv_icon;
    TextView tv_name;
    TextView tv_desc;
}

```


### 10.2 列表类视图

#### 10.2.1 ListView
ListView参考教程
1. [listview使用](https://blog.csdn.net/indeedes/article/details/119530068)


使用方式:
1. 创建布局ListView
2. 创建列表项
3. 创建适配器,将数据加载到列表项中
4. 获取布局,将适配器设置给该控件

这里讲解一下如何用ListView将购物车界面重构:
1. 购物车列表视图主要通过适配器将数据传递给界面,并且将界面进行更新.
2. 为该界面设置全局适配器,然后设计点击事件,实现购物车的删除
3. 删除逻辑主要在适配器中进行,通过适配器通知界面数据发生改变
    - `mCartAdapter.notifyDataSetChanged();`

代码:
```java
// 展示购物车的商品列表
private void showCart() {
    // 移除所有子视图
    // 查询购物车数据库的所有商品记录
    mCartList = mDBHelper.queryAllCartInfo();
    if (mCartList.size() == 0){
        return;
    }

    for (CartInfo info: mCartList) {
        // 根据商品编号查询商品数据库的商品记录
        GoodsInfo goods = mDBHelper.queryGoodsById(info.goodsId);
        mGoodsMap.put(info.goodsId, goods);
        info.goods = goods;
    }

    // 全局适配器
    mCartAdapter = new CartAdapter(this, mCartList);
    lv_cart.setAdapter(mCartAdapter);
    // 设置点击事件
    lv_cart.setOnItemClickListener(this);
    // 设置长按删除事件
    lv_cart.setOnItemLongClickListener(this);

        // 计算总金额
    refreshTotalPrice();

}


@Override
public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {
    CartInfo info = mCartList.get(position);
    AlertDialog.Builder builder = new AlertDialog.Builder(ShoppingCartActivity.this);
    builder.setMessage("是否从购物车移走" + info.goods.name + "?");
    builder.setPositiveButton("是",(dialog, which) -> {
        // 移除当前视图
        mCartList.remove(position);
        // 将适配器设置为全局的，通知适配器数据发生改变
        mCartAdapter.notifyDataSetChanged();
        // 删除该商品
        deleteGoods(info);
    });
    builder.setNegativeButton("否",null);
    builder.create().show();
    return true;
}
```


适配器代码:
```java
package com.example.week3test.adapter;
public class CartAdapter extends BaseAdapter {

    private Context mContext;
    private List<CartInfo> mCartList;

    public CartAdapter(Context mContext, List<CartInfo> mCartList) {
        this.mContext = mContext;
        this.mCartList = mCartList;
    }

    @Override
    public int getCount() {
        return mCartList.size();
    }

    @Override
    public Object getItem(int position) {
        return mCartList.get(position);
    }

    @Override
    public long getItemId(int position) {
        return position;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder holder;

        if (convertView == null) {
            holder = new ViewHolder();
            // 获取布局文件item_cart.xml根视图
            convertView = LayoutInflater.from(mContext).inflate(R.layout.item_cart,null);
            holder.iv_thumb = convertView.findViewById(R.id.iv_thumb);
            holder.tv_name = convertView.findViewById(R.id.tv_name);
            holder.tv_count = convertView.findViewById(R.id.tv_count);
            holder.tv_price = convertView.findViewById(R.id.tv_price);
            holder.tv_sum = convertView.findViewById(R.id.tv_sum);
            holder.tv_desc = convertView.findViewById(R.id.tv_desc);
            convertView.setTag(holder);
        } else {
            holder = (ViewHolder) convertView.getTag();
        }

        CartInfo info = mCartList.get(position);
        holder.iv_thumb.setImageURI(Uri.parse(info.goods.picPath));
        holder.tv_name.setText(info.goods.name);
        holder.tv_desc.setText(info.goods.description);
        holder.tv_count.setText(String.valueOf(info.count));
        holder.tv_price.setText(String.valueOf((int) info.goods.price));
        holder.tv_sum.setText(String.valueOf((int) (info.goods.price * info.count)));

        return convertView;
    }

    static class ViewHolder {
        public ImageView iv_thumb;
        public TextView tv_name;
        public TextView tv_desc;
        public TextView tv_count;
        public TextView tv_price;
        public TextView tv_sum;

    }
}


```


#### 10.2.2 GridView






### 10.3 翻页类视图
#### 10.3.1 ViewPager

ViewPager 是 Android 中一个强大的 UI 控件，用于实现页面左右滑动的效果。它通常用于实现应用程序的分页功能，如图片浏览器、向导页等。

1. ViewPager是一个容器，支持页面的左右滑动切换。
2. PagerAdapter是 ViewPager 的适配器，用于提供页面数据和页面视图。


使用步骤:
1. 布局组件
```xml
<androidx.viewpager.widget.ViewPager
        android:id="@+id/vp_content"
        android:layout_width="match_parent"
        android:layout_height="370dp"
        tools:ignore="SpeakableTextPresentCheck" />
```

2. 活动activity页面
```java
//onCreate函数
ViewPager vp_content = findViewById(R.id.vp_content);
mGoodsList = GoodsInfo.getDefaultList();
ImagePagerAdapter adapter = new ImagePagerAdapter(this, mGoodsList);
vp_content.setAdapter(adapter);
// 添加页面变更监听器
vp_content.addOnPageChangeListener(this);

```

3. 适配器继承自PagerAdapter
```java
package com.example.week3test.adapter;
public class ImagePagerAdapter extends PagerAdapter {

    private Context mContext;
    private ArrayList<GoodsInfo> mGoodsList;
    // 图像列表
    private List<ImageView> mViewList = new ArrayList<>();

    public ImagePagerAdapter(Context mContext, ArrayList<GoodsInfo> mGoodsList) {
        this.mContext = mContext;
        this.mGoodsList = mGoodsList;

        for (GoodsInfo info : mGoodsList) {
            ImageView view = new ImageView(mContext);
            view.setLayoutParams(new ViewGroup.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.WRAP_CONTENT

            ));
            view.setImageResource(info.pic);
            mViewList.add(view);
        }

    }

    @Override
    public int getCount() {
        return mViewList.size();
    }

    @Override
    public boolean isViewFromObject(@NonNull View view, @NonNull Object object) {
        return view == object;
    }


    // 实例化指定位置，并且添加到容器中
    @NonNull
    @Override
    public Object instantiateItem(@NonNull ViewGroup container, int position) {
        // 添加一个view到container中，然后返回一个根这个view可以关联起来的对象
        // 这个view可以是自己，也可以是其他无关的对象
        // 关键是在isViewFromObject可以将view和这个object关联起来
        ImageView item = mViewList.get(position);
        container.addView(item);
        return item;
    }


    // 从容器中销毁指定位置的页面
    @Override
    public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
        container.removeView(mViewList.get(position));
    }
}

```


#### 10.3.2 翻页标签栏PagerTabStrip





#### 10.3.3 ViewPager实现启动引导页

主要步骤：
1. 设置单个页面布局(item_launch.xml)：
```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ImageView
        android:id="@+id/iv_launch"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:scaleType="fitXY"/>

    <RadioGroup
        android:id="@+id/rg_indicate"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:paddingBottom="20dp"
        android:layout_centerHorizontal="true"
        android:orientation="horizontal"/>


<!--    // 按钮-->
    <Button
        android:id="@+id/btn_start"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="立即开始美好生活"
        android:textColor="#ff3300"
        android:textSize="22sp"
        android:visibility="gone"/>

</RelativeLayout>
```

2. 设置好启动总页面布局(launch_simple.xml)
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <androidx.viewpager.widget.ViewPager
        android:id="@+id/vp_image_content"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:ignore="SpeakableTextPresentCheck" />

</LinearLayout>

```

3. 设置viewPager启动页面的适配器
    - 将图片、单选按钮等加载到页面，然后插入容器
```java
package com.example.week3test.adapter;
public class LaunchSimpleAdapter extends PagerAdapter {

    private List<View> mViewList = new ArrayList<>();

    public LaunchSimpleAdapter(Context mContext, int[] imageArray) {
        for (int i = 0; i < imageArray.length; i++) {
            View view = LayoutInflater.from(mContext).inflate(R.layout.item_launch, null);
            ImageView iv_launch = view.findViewById(R.id.iv_launch);
            RadioGroup rg_indicate = view.findViewById(R.id.rg_indicate);
            Button btn_start = view.findViewById(R.id.btn_start);
            iv_launch.setImageResource(imageArray[i]);

            // 每一个页面分配一组对应的按钮
            for (int i1 = 0; i1 < imageArray.length; i1++) {
                RadioButton radio = new RadioButton(mContext);
                radio.setLayoutParams(new ViewGroup.LayoutParams(
                        ViewGroup.LayoutParams.WRAP_CONTENT,
                        ViewGroup.LayoutParams.WRAP_CONTENT
                ));
                radio.setPadding(10,10,10,10);
                rg_indicate.addView(radio);
            }

            // 当前位置的单选按钮要高亮显示
            ((RadioButton)rg_indicate.getChildAt(i)).setChecked(true);

            // 最后一个页面按钮展示
            if(i == imageArray.length - 1){
                btn_start.setVisibility(View.VISIBLE);
                btn_start.setOnClickListener(v -> {
                    ToastUtil.show(mContext, "欢迎开启美好生活");
                });
            }

            mViewList.add(view);
        }
    }

    @Override
    public int getCount() {
        return mViewList.size();
    }

    @Override
    public boolean isViewFromObject(@NonNull View view, @NonNull Object object) {
        return view == object;
    }

    @NonNull
    @Override
    public Object instantiateItem(@NonNull ViewGroup container, int position) {
        // 添加一个view到container中，然后返回一个根这个view可以关联起来的对象
        // 这个view可以是自己，也可以是其他无关的对象
        // 关键是在isViewFromObject可以将view和这个object关联起来
        View item = mViewList.get(position);
        container.addView(item);
        return item;
    }


    // 从容器中销毁指定位置的页面
    @Override
    public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
        container.removeView(mViewList.get(position));
    }

}
```

4. activity页面
```java
// 全局变量
// 声明图片
private int[] launchImageArray = {
        R.drawable.guide_bg1,
        R.drawable.guide_bg2,
        R.drawable.guide_bg3,
        R.drawable.guide_bg4,
};

//生命周期函数
ViewPager vp_content = findViewById(R.id.vp_image_content);
// 设置适配器
LaunchSimpleAdapter adapter = new LaunchSimpleAdapter(this, launchImageArray);
vp_content.setAdapter(adapter);

```


### 10.4 碎片Fragment
Fragment 是 Android 应用程序中的一个模块化组件，允许在一个 Activity 中创建多个独立的 UI 组件。Fragment 可以动态添加、替换、移除，它们通常用于实现多视图、多面板的 UI。

1. 主要特点
    - 可以在一个 Activity 内部重用 UI 组件。
    - 每个 Fragment 有自己的生命周期，与宿主 Activity 的生命周期相关联。
    - 可以在运行时动态添加或移除 Fragment。
2. 典型用法
    - 静态添加 Fragment：通过在 XML 布局文件中定义 Fragment。
    - 动态添加 Fragment：通过编程方式在运行时添加、替换或移除 Fragment。


#### 10.4.1 静态注册Fragment
静态添加 Fragment 是指在 XML 布局文件中预定义 Fragment，使其在包含该布局的 Activity 或 Fragment 启动时自动添加到用户界面中。这种方法使 Fragment 成为布局的一部分，并在应用运行时不可动态移除。

1. 创建 Fragment 类

首先，创建一个 Fragment 类。这通常是一个继承自 `Fragment` 的类，并重写 `onCreateView` 方法以定义其布局。

```java
package com.example.myapp;
public class MyFragment extends Fragment {

    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.fragment_my, container, false);
    }
}
```


2. 定义 Fragment 的布局

接下来，为 Fragment 创建一个布局文件（`fragment_my.xml`）。这个文件将定义 Fragment 的用户界面。

```xml
<!-- res/layout/fragment_my.xml -->
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello from MyFragment!"
        android:textSize="18sp"/>
        
</LinearLayout>
```

3. 在 Activity 布局中添加 Fragment

将 Fragment 添加到 Activity 的布局中。在 Activity 的布局文件中，使用 `<fragment>` 标签定义 Fragment。

```xml
<!-- res/layout/activity_main.xml -->
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <fragment
        android:id="@+id/my_fragment"
        android:name="com.example.myapp.MyFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

</RelativeLayout>
```

在这个例子中，`android:name` 属性指定了要使用的 Fragment 类的完全限定名。系统会自动创建这个 Fragment 并将其添加到布局中。







### 10.5 记账本



